{
    "success": true,
    "data": [
        {
            "id": "5e4fa8531225c9423dcda9d8",
            "author_id": "51f0f267f4963ade0e08f503",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><ul>\n<li>想了解大家都是如何使用 Node.js？</li>\n<li>想看看大家都在关注些什么？</li>\n<li>想看看 Noder 的分布？</li>\n</ul>\n<p>欢迎您来参加 Node.js 开发者调查问卷，希望您能抽出一点时间，将您的感受和建议告诉我们，我们非常重视每位开发者的宝贵意见。\n问卷结束后我们会给留邮箱的同学第一时间电邮分析报告，期待您的参与！</p>\n<p>这大约需要花费您 3~5 分钟，链接请戳：<a href=\"https://www.wjx.cn/jq/62950743.aspx\">https://www.wjx.cn/jq/62950743.aspx</a></p>\n<p>钉钉/微信等 app 扫码也可以进入问卷</p>\n<p><img src=\"//static.cnodejs.org/FrFrspXfOx2GGwqY_cMFManessGS\" alt=\"image.png\"></p>\n</div>",
            "title": "Node.js 开发者调查问卷",
            "last_reply_at": "2020-04-08T09:44:12.806Z",
            "good": false,
            "top": true,
            "reply_count": 10,
            "visit_count": 14491,
            "create_at": "2020-02-21T09:52:19.108Z",
            "author": {
                "loginname": "lellansin",
                "avatar_url": "https://avatars2.githubusercontent.com/u/2081487?v=4&s=120"
            }
        },
        {
            "id": "5e16978581adfe260207a8c1",
            "author_id": "54009f5ccd66f2eb37190485",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h2>活动信息</h2>\n<p><img src=\"//static.cnodejs.org/Fsqzwb41k7ivzIJn810EEwPQ_2it\" alt=\"1111.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fu_XCoMAB8uUlFYPGWQ3ncssCb8t\" alt=\"2222.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fge-hr_LF_guf0BbwQ9xmi0unnNi\" alt=\"33333.png\"></p>\n<p>本次活动需要提前报名，场地大约有100人</p>\n<p>报名连接</p>\n<p><a href=\"https://www.huodongxing.com/event/5526816284100?utm_source=%E5%8F%91%E7%8E%B0%E6%B4%BB%E5%8A%A8%E9%A1%B5&amp;utm_medium=&amp;utm_campaign=eventspage\">https://www.huodongxing.com/event/5526816284100?utm_source=发现活动页&amp;utm_medium=&amp;utm_campaign=eventspage</a></p>\n<h2>PPT</h2>\n<p><a href=\"https://github.com/i5ting/nodeparty-beijing-2020-1-11\">https://github.com/i5ting/nodeparty-beijing-2020-1-11</a></p>\n<h2>照片</h2>\n<p>龙佳文\n<img src=\"//static.cnodejs.org/Fg4dIjPNKksKiOMmyIgGMEg1087O\" alt=\"111 1.jpg\"></p>\n<p>十忆\n<img src=\"//static.cnodejs.org/Fs9J2dxbgickUDOzM7Vwuxd7HVKF\" alt=\"222 1.jpg\">\n狼叔\n<img src=\"//static.cnodejs.org/Fhc9AmVNEbqAdmxOUTYwIN7XdYU_\" alt=\"3333 1.jpg\">\n王东\n<img src=\"//static.cnodejs.org/FssLOS3hMlVq658eD_yb3CJpeW8C\" alt=\"4444 1.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fsuj39b-PoVOS65vAoVgFqbR9m8Q\" alt=\"5555 1.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FiTD21bRAzZZbpCueJRk7Uq-Ik7i\" alt=\"7777 1.jpg\">\n现场提问\n<img src=\"//static.cnodejs.org/Fm6ssdq_P6JNaftwAZ_AyiXtVIxb\" alt=\"8888 1.jpg\">\n流司\n<img src=\"//static.cnodejs.org/FoqgjwSNssTlJ1ufnowc1jxx_imR\" alt=\"9923 1.jpg\">\n现场提问\n<img src=\"//static.cnodejs.org/FplNNONJOacRNbvnvc7EBl1sgN8U\" alt=\"9999 1.jpg\">\n现场\n<img src=\"//static.cnodejs.org/Fl--jBm9nfRCmNPCvL92TrlkvdGT\" alt=\"11212 1.jpg\"></p>\n<p>圆桌会\n<img src=\"//static.cnodejs.org/Fq7xH6d9K1bor6ixUFY1AEO4d8GU\" alt=\"23323e4ds 1.jpg\">\n<img src=\"//static.cnodejs.org/FulUvueqoTJ8nIGlOgJTD1JFGDPA\" alt=\"322332.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Ftw6oRg8G-eeqQ2SLrwiaj671sMF\" alt=\"稳稳稳.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FozWsIovHilxYBlJ-I8LmYW-gNhi\" alt=\"32323.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fvhek3xeqE4afj41AuB5Vuj7MwSr\" alt=\"43434.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FvM4WhrhpkRT9sZ3CxsbGy8OX7bH\" alt=\"55545.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fh7MgA9zXpT3Gc-1UfXsd3o8FB6F\" alt=\"111110.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fr6oow-uHpFkkoVo2xIaw3Xm-gdI\" alt=\"232323.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fl3A1Ijt8IeE9XHT9DNNUM_I0OkB\" alt=\"232332.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FobbWO7B2JwwszK80ZpJT8Pl6f0Y\" alt=\"322323.jpg\">\n<img src=\"//static.cnodejs.org/Fr7qQvzHT6pLInnX9m6JeFZEjKYC\" alt=\"812312.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FinFnUdjTZjt2DAdjC5H-DsYZ4Fa\" alt=\"882323.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fq-nKPQt4JeiBZAQKft6vW49pGiB\" alt=\"3434389.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FuAt3QuZ-Y9E21EMrkn05JAcPLsf\" alt=\"9999923.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FkpIr82doXBBk7VH1aGM6zD16qZ-\" alt=\"23323232323.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FiKYZ46Ilm5OVT_Tunhmga8x-vrr\" alt=\"232323232332.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FqOE05r204gsYDWp-m9p04Vf1ME_\" alt=\"aaa.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FmRRAzINYs-j5hF-n7-LZKscD23e\" alt=\"bbbb.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FjIIelIuczqPkJjWSKC5wEtv3uzD\" alt=\"cccc.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FjIIelIuczqPkJjWSKC5wEtv3uzD\" alt=\"cccc.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FtponmJNP2UD0qemwD_1vBBa0ibK\" alt=\"dddd.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fv0LVdt1X6RizMg5gp2CerH1pIMH\" alt=\"dfdfd.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fgw6rAtxlJg9fWLlQNM4gwozWlVj\" alt=\"eeeee.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FlnX4CFVmxrFQXmNWYQuwt6Ar4Et\" alt=\"EmptyName 2.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FnnoaFaMof3IxOR9sWJIj6jrjcPx\" alt=\"hjkl;'.jpg\"></p>\n<p>王东\n<img src=\"//static.cnodejs.org/FhNqWIas9yk1XuYvNHtijUzB40BK\" alt=\"jhklsd.jpg\"></p>\n<p>嘉宾合影\n<img src=\"//static.cnodejs.org/FvKMqpc7UZhVeRKXUNvtY8FuBAEh\" alt=\"上3.jpg\"></p>\n<p>狼书签名\n<img src=\"//static.cnodejs.org/FgxEWL85ZMEA8qpVakAvvSUWEmVd\" alt=\"23e4232 1.jpg\"></p>\n<h2>视频</h2>\n<p>面向B端工作台的微前端方案-ConsoleOS-徐博文\n<a href=\"https://edu.talkingdata.com/open-class?id=142\">https://edu.talkingdata.com/open-class?id=142</a></p>\n<p>Serverless在美团的实践-龙佳文\n<a href=\"https://edu.talkingdata.com/open-class?id=143\">https://edu.talkingdata.com/open-class?id=143</a></p>\n<p>前端生态建设在瓜子的落地实践-王东\n<a href=\"https://edu.talkingdata.com/open-class?id=144\">https://edu.talkingdata.com/open-class?id=144</a></p>\n<p>Egg-React-SSR深度解析-张宇昂\n<a href=\"https://edu.talkingdata.com/open-class?id=145\">https://edu.talkingdata.com/open-class?id=145</a></p>\n<p>如何融入并贡献开源-Justjavac\n<a href=\"https://edu.talkingdata.com/open-class?id=146\">https://edu.talkingdata.com/open-class?id=146</a></p>\n<p>圆桌讨论\n<a href=\"https://edu.talkingdata.com/open-class?id=147\">https://edu.talkingdata.com/open-class?id=147</a></p>\n</div>",
            "title": "2020年1月11日Node party@北京成功举办，附照片、视频和ppt",
            "last_reply_at": "2020-04-03T15:43:22.565Z",
            "good": true,
            "top": true,
            "reply_count": 10,
            "visit_count": 21492,
            "create_at": "2020-01-09T03:01:25.190Z",
            "author": {
                "loginname": "i5ting",
                "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
            }
        },
        {
            "id": "5cbfd9aca86ae80ce64b3175",
            "author_id": "4f447c2f0a8abae26e01b27d",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h2>前言</h2>\n<p>时隔一年，Node.js 12 如约而至，正式发布第一个 <a href=\"https://github.com/nodejs/Release\">Current</a> 版本。</p>\n<p>该版本带来了诸如：</p>\n<ul>\n<li>V8 更新带来好多不错的特性。</li>\n<li>HTTP 解析速度提升。</li>\n<li>启动速度大幅提升。</li>\n<li>更好的诊断报告和堆分析工具。</li>\n<li>ESM 模块更新。</li>\n</ul>\n<p>原文地址：<a href=\"https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f\">https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f</a>\n语雀地址：<a href=\"https://www.yuque.com/egg/nodejs/nodejs-12\">https://www.yuque.com/egg/nodejs/nodejs-12</a></p>\n<h2>LTS vs Current</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556074709431-35af45b8-ec7a-4a81-83d8-155eb519f04a.png#align=left&amp;display=inline&amp;height=389&amp;name=image.png&amp;originHeight=500&amp;originWidth=960&amp;size=58313&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>如果你不了解 Node.js 的  Long Term Support 发布策略的话，一定要看看 <a href=\"https://github.com/nodejs/Release\">https://github.com/nodejs/Release</a> 。</p>\n<p>就目前而言，Node.js 6.x 和 8.x 将在 2019 年末结束 LTS 的支持，大家尽快升级到 10.x 吧。</p>\n<h2>快速体验</h2>\n<pre class=\"prettyprint language-bash\"><code>$ nvs add node&#x2F;12\n$ nvs use 12\n$ node -v\nv12.0.0\n</code></pre><p>具体参考这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/63403762\">科普文：使用 nvs 管理本地 Node.js 版本</a></p>\n<h2>V8 更新到 7.4</h2>\n<blockquote>\n<p>大部分情况下，我们不用去考虑性能问题，坐等 V8 版本更新就好了。（大雾）</p>\n</blockquote>\n<p>本次版本更新，也带来了好几个不错的特性：</p>\n<ul>\n<li><a href=\"https://v8.dev/blog/v8-release-72#async-stack-traces\">异步堆栈跟踪</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-74#faster-calls-with-arguments-mismatch\">参数调用不匹配时的调用速度优化</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-73#faster-await\">更快的 await</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-72#javascript-parsing\">更快的 JavaScript 解析速度</a></li>\n</ul>\n<p><strong>同时，跑了下我们 Egg 的一些内部测试，发现序列化有 10~20% 的性能提升，恐怖如斯！</strong></p>\n<p>另，奇丑无比的 <a href=\"https://github.com/tc39/proposal-class-fields\">Private Class Fields</a> 也能用了：</p>\n<pre class=\"prettyprint language-javascript\"><code>class IncreasingCounter {\n  #count = 0;\n  \n  get value() {\n    console.log(&#x27;Getting the current value!&#x27;);\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\n</code></pre><h2>HTTP 解析速度提升</h2>\n<p>默认的 HTTP 解析器切换为 <a href=\"https://github.com/nodejs/llhttp\">llhttp</a> ，性能提升恐怖如斯：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556072499637-686bb0e3-c75c-424c-851f-ad88aff183a2.png#align=left&amp;display=inline&amp;height=231&amp;name=image.png&amp;originHeight=404&amp;originWidth=1302&amp;size=88775&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>启动速度提升</h2>\n<p>通过 <a href=\"https://v8.dev/blog/code-caching\">v8 code cache</a> 的支持，<a href=\"https://github.com/nodejs/node/pull/27161\">在构建时提前为内置库生成代码缓存</a>，从而提升 30% 的启动耗时。\n同时，通过<a href=\"https://github.com/nodejs/node/pull/24950\">重用主进程缓存</a>，Workers Threads 的启动速度提升了 60% 。</p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>Workers Threads</h2>\n<p>在 10.x 已经引入的 <a href=\"https://nodejs.org/api/worker_threads.html\">Workers Threads</a> 特性，在 12.x 里面默认启用，无需使用 <code>--experimental-worker</code> 开启。同时基于上一条的介绍，启动的速度也得到大幅提升。</p>\n<p>相关介绍：<a href=\"https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6\">https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6</a></p>\n<h2>诊断报告</h2>\n<p>提供了新的实验性功能『诊断报告』，一个非常有用的特性。\n可用于帮助分析诸如：崩溃，性能问题，内存泄漏，高 CPU 占用等等问题。详见 <a href=\"https://medium.com/the-node-js-collection/easily-identify-problems-in-node-js-applications-with-diagnostic-report-dc82370d8029\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：这也是 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 之前的一个卖点之一。</p>\n</blockquote>\n<h2>Heap Dump</h2>\n<p>以前我们分析问题的时候，需要手动安装对应的类库或者使用 AliNode。</p>\n<p>在 12.x 里面内置了该功能，详见：</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/node/pull/27133\">https://github.com/nodejs/node/pull/27133</a></li>\n<li><a href=\"https://github.com/nodejs/node/pull/26501\">https://github.com/nodejs/node/pull/26501</a></li>\n</ul>\n<blockquote>\n<p>点评：又一个 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 的功能被内置了。但其实影响不大，AliNode 的核心在于分析平台，这块的采集能力，本来他们就打算开源回馈出去的。</p>\n</blockquote>\n<p>同时，由于上述提到的 V8 升级，现在可以按照可用内存动态调整堆大小了。</p>\n<h2>ESM 模块方案更新</h2>\n<p>ES6 模块仍然还在实验阶段，不过有了新的方式，具体参见<a href=\"https://medium.com/@nodejs/announcing-a-new-experimental-modules-1be8d2d6c2ff\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：让子弹再飞一会，该特性真的不是痛点，不急。</p>\n</blockquote>\n<h2>其他更新</h2>\n<ul>\n<li>更好的原生模块支持，<a href=\"https://nodejs.org/api/n-api.html#n_api_n_api\">N-API</a> 升级为版本 4，并 backport 到 Node.js 8.x 和 10.x。详细参见<a href=\"https://medium.com/the-node-js-collection/new-features-bring-native-add-ons-close-to-being-on-par-with-js-modules-cd4f9b8e4b4\">这篇文章</a>。</li>\n<li>TLS 升级为 1.3， <a href=\"https://developer.ibm.com/blogs/openssl-111-has-landed-in-nodejs-master-and-why-its-important-for-nodejs-lts-releases/\">增强安全功能</a>。</li>\n<li>随着 C++ 编译器的更新，现在要求 <code>GCC 6</code> 和 <code>glibc 2.17</code> ，对应的操作系统 Win7 和 macOS 10，详细参见<a href=\"https://github.com/nodejs/node/blob/v12.x/BUILDING.md#platform-list\">这篇文章</a>。</li>\n</ul>\n<p>不过目前 node-gyp 的一些原生模块会编译失败：</p>\n<pre class=\"prettyprint language-bash\"><code>nunjucks@3.2.0 › chokidar@2.1.5 › fsevents@^1.2.7 optional error: Error: Run &quot;sh -c node install&quot; error, exit code 1\n    at ChildProcess.&lt;anonymous&gt; (&#x2F;Users&#x2F;tz&#x2F;.npm-global&#x2F;lib&#x2F;node_modules&#x2F;tnpm&#x2F;node_modules&#x2F;_runscript@1.3.0@runscript&#x2F;index.js:74:21)\n    at ChildProcess.emit (events.js:196:13)\n    at maybeClose (internal&#x2F;child_process.js:1000:16)\n    at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:267:5)\n</code></pre></div>",
            "title": "Node 12 值得关注的新特性",
            "last_reply_at": "2020-03-26T07:32:32.469Z",
            "good": false,
            "top": true,
            "reply_count": 90,
            "visit_count": 302686,
            "create_at": "2019-04-24T03:36:12.582Z",
            "author": {
                "loginname": "atian25",
                "avatar_url": "https://avatars2.githubusercontent.com/u/227713?v=4&s=120"
            }
        },
        {
            "id": "5e154d7b4bea432607fcd616",
            "author_id": "5d9c9150865a9844a301a09e",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>由蚂蚁金服体验科技主办的第三届 SEE Conf 已于 2020 年 1 月 4 日在杭州西湖问题中心圆满举办，所有话题 Slide 已上传，欢迎查看： <a href=\"https://link.zhihu.com/?target=https%3A//www.yuque.com/seeconf/2020/slide\">https://www.yuque.com/seeconf/2020/slide</a>\n现场图片地址：<a href=\"https://link.zhihu.com/?target=https%3A//v.alltuu.com/album/1010414342/\">https://v.alltuu.com/album/1010414342/</a></p>\n<p>这是对第三届 SEE Conf 做的（略长的）现场报道，希望能为大家带来收获，也感谢组委会、感谢所有讲师、感谢所有参会者，这场体验科技的盛筵，我真的大开眼界、收获良多！！</p>\n<p>早上 7 点半，工作人员就已在现场等候参会者到来～</p>\n<h2>虚位以待</h2>\n<p><img src=\"https://pic2.zhimg.com/80/v2-93830c3013b971b38b80c7f8ed8289f0_hd.jpg\" alt=\"五彩斑斓的「白」\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-b726337362c025340ae26120cdfab1bb_hd.jpg\" alt=\"SEEConf主会场\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-1c6269a3006597f3d0a981bc658c8aec_hd.jpg\" alt=\"设计师们利用油漆桶做的签到指引\">\n设计师们利用油漆桶做的签到指引</p>\n<h2>参会者们陆续到来</h2>\n<p><img src=\"https://pic4.zhimg.com/80/v2-a887bcef020cf58d9c1dd7f4f4e5fa50_hd.jpg\" alt=\"签到台\"></p>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*gyfTTKjgzm8AAAAAAAAAAABkARQnAQ\" alt=\"这位小姐姐笑得好灿烂\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-678dbfacfc4a7cee68a5ab94610dd23f_hd.jpg\" alt=\"确认参会信息\"></p>\n<h2>前端大咖们都来签到啦</h2>\n<p><img src=\"https://pic1.zhimg.com/80/v2-807df423686e2b7440ca413ceeb3eabc_hd.jpg\" alt=\"天猪\">\n天猪</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-0e34c1c76c701f807160d2d32e05e11f_hd.jpg\" alt=\"完颜\">\n完颜</p>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*QnVaTbgeZ9AAAAAAAAAAAABkARQnAQ\" alt=\"Hax也来了~别打我。。\">\nHax 也来了！别打我。。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-68819bbfb10ef71f174fcac933130632_hd.jpg\" alt=\"徐飞\">\n徐飞</p>\n<h2>独具创意的展台</h2>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*gD16QKGk4NsAAAAAAAAAAABkARQnAQ\" alt=\"AntV连线互动\">\nAntV 连线互动</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-e12ca88510f61dfb26566ee469a13a7a_hd.jpg\" alt=\"AntDesign自由贴纸\">\nAnt Design 自由贴纸</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-10902588cd5dfd7c2691e021dcc4920b_hd.jpg\" alt=\"Oasis3D真人传感游戏（Yeah, that is me）\">\nOasis 3D 真人传感游戏（Yeah, that is me）</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-5dba4dd82a1a4348b8833e0b14dfa559_hd.jpg\" alt=\"他们在围观什么呢？\">\n他们在围观什么呢？</p>\n<h2>帅气的保安大队</h2>\n<p><img src=\"https://pic2.zhimg.com/80/v2-30fd6acf607d05b4cb624d69fe24dd3b_hd.jpg\" alt=\"猜猜哪位是我老板！\">\n猜猜哪位是我老板！</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-36f10565f9a82981dab229dd24af324b_hd.jpg\" alt=\"中间乱入了？？\">\n中间乱入了？？</p>\n<h2>参会者们陆续入场，高朋满座</h2>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*3AMMQ6lTnlsAAAAAAAAAAABkARQnAQ\" alt=\"排队进场\">\n排队进场</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-0e8855f45c442a1a4cb98a215e21e200_hd.jpg\" alt=\"高朋满座\">\n高朋满座</p>\n<h2>玉伯作开幕致辞「体验科技和好的产品」</h2>\n<p>在第一届 SEE Conf 上，玉伯 <a href=\"https://www.zhihu.com/people/c11336b8607d86bc9090bed90757a34c\">@玉伯</a> 讲了「体验云」的故事，介绍了什么是「体验科技」——技术与设计的融合，服务与用户的链接，以及重点介绍体验云可以带给用户什么服务。</p>\n<p>在第二届 SEE Conf 上，玉伯发表了「体验科技与好的社会」主题致辞，表达了希望通过体验从业者的发展、体验的普惠与创新，让社会变得更好的愿景。</p>\n<p>本届 SEE Conf, 玉伯又从体验谈起，和我们分享什么是好的产品。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-91f8d3cdd5aa464559a972ed901a584f_hd.jpg\" alt=\"体验科技和好的产品\"></p>\n<p>他引用了张小龙的十条「好的产品」原则，以及俞军对用户价值的衡量，从科技视角下提出好产品的公式「好用 = 效用 + 爱用 」。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-1b968e8e29f50a76ebffd12c1b75d445_hd.jpg\" alt=\"张小⻰谈「好的产品」\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-d48adeef7f53c11ea88361bb5c15d270_hd.jpg\" alt=\"俞军谈用户价值\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-6f8908fd3837914c4655f841c495dd97_hd.jpg\" alt=\"好用=效用+爱用\"></p>\n<p>最后，回归体验科技的初心——<strong>体验科技，致力于让产品更美好</strong>。</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-48e5049d748d345faf78a1c982b381f0_hd.jpg\" alt=\"体验科技\"></p>\n<h2>湖南大学艺术学院院长 何人可「基于地域文化的设计创新」</h2>\n<p>何院长院长是中国设计日的三大倡导者之一，著有《工业设计史》一书，桃李满天下。本次 SEE Conf 上，他向我们展示了世界各地的特色文化，湖南地区的少数民族设计，以及许多人都感兴趣的<strong>色彩模型</strong>。他展示的短片令无数参会者感叹——这不正是我们 #向往的生活# 吗？</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-60ededbc07ccd17acae1fe9bf6034401_hd.jpg\" alt=\"何人可院长\"></p>\n<h2>蚂蚁金服设计师们分享「Ant Design 4.0: 创造快乐工作」</h2>\n<p>蚂蚁金服 高级体验设计专家 林外 <a href=\"https://www.zhihu.com/people/5130d41cb0ba2a363c4d81904d1377e2\">@林外</a> 引入了 Ant Design 4.0 全新的基本假定：每个人都追求快乐工作，并由此衍生出了四个价值观。着重介绍了「自然」这个价值观，其理念就是「法自然」，让功能去找用户，节省用户脑力体力。Ant Design 4.0 在设计上也遵循这个原则。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-636ddc69d1bd8482e9c9a020c500b9ac_hd.jpg\" alt=\"林外：每个人都追求快乐工作\"></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-250f88192755339a453fc2e751d55bb6_hd.jpg\" alt=\"Ant Design 四大价值观\"></p>\n<p>然后，他为我们引入了体验技术部的三种设计资产。</p>\n<h2>UI 可视化资产</h2>\n<p>UI 资产是三大资产中最基础也最重要的部分！我们日常在 Ant Design 以及 Ant Design Pro 中，都能见到 UI 资产的身影。有人可能会认为，既然是资产库，那肯定要大而全，越多越好。可事实真的如此吗？</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-774c26adf14c44bb3b508d977a1b2e33_hd.jpg\" alt=\"UI 资产，真的越多越好么\"></p>\n<p>林外举了个「幽灵按钮」的例子，设计师都知道幽灵按钮是没有底色的按钮，许多网站也都会提供，但大家却说不出来，它到底该怎么用、用在哪里？</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-b1d1e9c3d3dd9ebfb78528ac0e4ed525_hd.jpg\" alt=\"幽灵按钮\"></p>\n<p>那么对于幽灵按钮这种「资产」，Ant Design 的态度是「克制」—— 我们能做，但我们（已经）想清楚了，不做。正是这种克制，让 Ant Design 的组件数量，从 2015 年以来的 20 个，增长到 2019 年的 61 个，仅仅翻了三倍。也正是这种克制，将 Ant Design 服务的用户数得到了指数级增长，由 5W 增长到了 526W，翻了一百多倍！这也呼应了玉伯前面提到的「少就是多」。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-491533ce39cc0f48bf026972d7837213_hd.jpg\" alt=\"UI 资产，Less is More\"></p>\n<h2>Kitchen 可视化资产</h2>\n<p>这里幕阑 <a href=\"https://www.zhihu.com/people/820bfa49454736091fed179f4a39335b\">@Moonland</a> 与我们分享了她的朋友 Kevin 的故事～</p>\n<p>Kevin 被产品经理委托了一个设计任务。原本需要 38 分钟的可视化设计工作，在 Kitchen 的辅助下，Kevin 仅花了三分钟即可完成。并且，他告诉他的工程师朋友 Tony-你可以不用来上班了，代码我都可以给你。又转过头告诉产品经理-你可以不用来上班了，我这个是可配置的。就这样，他们实现了「快乐工作」，2333～</p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//kitchen.alipay.com/\">Kitchen 的 sketch 插件</a>我自己也在用喔！打 Call Call!</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-73bfa9371035709fe2600bd75878d89e_hd.jpg\" alt=\"幕阑-我的朋友 Kevin 的故事\"></p>\n<h2>HiTu 图形资产</h2>\n<p>HiTu 提供了丰富多彩的图形组件，通过拖拽式的交互，即可快速生成一个页面。蚂蚁金服高级体验设计师 线丝 仅用两分钟，就完成了他老板的「一张纸需求」的设计和修改。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-b5d473eec2af8af84e254ab97b09a968_hd.jpg\" alt=\"线丝讲 HiTu\"></p>\n<p>在基本假定以及四大设计价值观之上，加上三类设计资产和两种设计策略，以及为开发者提供的配套工具，构成了 Ant Design 4.0 的全景图。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-676ab78c1c500e76f53ae1da0423cede_hd.jpg\" alt=\"Ant Design 4.0\"></p>\n<h2>幻鹦数字驾驶舱</h2>\n<p>来自图形与艺术实验室的产品经理 可言、设计师 十喜 和工程师 逸达 分别从社会数字化需要（幻鹦缘起）、标准结构和设计体系以及可视化设计中台的落地三方面，为我们全方位介绍了幻鹦数字驾驶舱——决策机构体验科技。这个项目还落地了政府的一个大（bao）型（mi）项目，斯国一！</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-7f165c01fb130233e8ad99aeacccc0f0_hd.jpg\" alt=\"可言-缘起\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-0d4f966f8e87e442f2ad8e77b3dd246d_hd.jpg\" alt=\"十喜小姐姐好漂亮！\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-b38f174d9114418e74dd19faca993760_hd.jpg\" alt=\"幻鹦整体架构\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-c060c98a9351b7d813f6cab0964bc709_hd.jpg\" alt=\"逸达与幻鹦中台\"></p>\n<p>对幻鹦中台印象比较深刻的是它的美术资源自动生成管线和渲染引擎。</p>\n<p>他们原本采用 2080Ti 显卡渲染 8K 场景，出现了肉眼可见的卡顿（13FPS），所以他们另辟蹊径，使用了分布式渲染技术，6 台渲染集实时同步渲染，十分流畅（60FPS）。</p>\n<p>再补充一句！幻鹦的宣传视频超级炫酷啊，感觉在看科幻电影一样！制作费<strong>一定很贵吧</strong>！ 0 0</p>\n<h2>在支付宝做前端是什么样的体验？</h2>\n<p>这里播放了支付宝自制的一组短片，几位工程师讲述了自己在支付宝做前端开发的体验，我在打字没有仔细听。。我自己的答案是——<strong>累，真累，但也快乐</strong>着吧，哈哈。</p>\n<p>然后加里介绍了几款自己的产品，并打了个招聘硬广。小程序 IDE 的开发体验，em… 继续加油哈！公益应用比如蚂蚁森林、蚂蚁庄园等还是很棒哒！一起养鸡一起种树，让世界更加美好鸭！</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-6c21841bf280332d399c52b117bc0de9_hd.jpg\" alt=\"加里\"></p>\n<h2>智能可视化体系 AVA</h2>\n<p>早上的最后一场分享，数据可视化专家 步茗 为我们带来了额支持可视化图表、智能化分析的 AVA, 据说可以解决后端、前端、设计一条龙的痛点。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-391acb51c543bbd0b7b9e9fe6cc3ea4b_hd.jpg\" alt=\"img\"></p>\n<p>前端开发专家 缪明 上场进行了多次 Live Coding, 只需选择图表类型，即可一键拷贝模拟数据以及图表配置到代码中，无缝切换。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-3daf3e88c91875e5ff4d4721249710c6_hd.jpg\" alt=\"缪明 Coding\"></p>\n<p>如果遇到「一句话需求」怎么办呢？他们也提供基于数据的图表智能推荐能力——录入数据，系统就会智能生成几种推荐图表，任君选择。</p>\n<p>提到这个我想起了最近看的「<strong>Google 必修的图表简报术</strong>」（推荐），也是提出了人们对图表的各种误用，并提出一套具体的方法论及可执行的操作方法。希望后面可以与大家分享～</p>\n<p>回到 AVA, 除了以上提供的能力，步茗还与我们畅想了研发态、阅读态、分析态等方案，希望能提供更多智能的能力，例如智能计算拟合曲线等，期待！</p>\n<hr>\n<p>吃过午饭，逛了一圈之后，下午场分享开始啦～</p>\n<h2>Remax - React + 小程序的新探索</h2>\n<p>许多团队都在尝试使用 React 开发小程序，但目前社区里大都是使用静态编译的方式把类似 React 语法的代码转换到小程序代码，之前在 Vue Conf 也听过类似的话题。</p>\n<p>而蚂蚁金服高级前端工程师 边柳 则另辟蹊径，打破小程序静态模板的限制，将 React 运行到小程序环境里，把完整的 React 开发体验带到小程序的开发中，打通小程序跟 React 的生态。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-a44fca41d8b3c365e374ccc7340c8d90_hd.jpg\" alt=\"边柳\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-dec1c428c43c7bc3ac57086eaeae9ad0_hd.jpg\" alt=\"静态编译的限制\"></p>\n<p>接着便是知乎、Node 网红，Egg.js 核心开发者，蚂蚁金服高级前端技术专家，我本次的战友 <a href=\"https://www.zhihu.com/people/9d9f94035b55b89236c232b15c7d9190\">@天猪</a> 带来的 SFF 分享啦～</p>\n<h2>Evolution: Serverless For Frontend - 探索下一代 Node 研发模式</h2>\n<p>前后端分层 BFF 的概念深入人心，但社区实践上却两级分化，很多公司落地艰难。最近热火朝天的 Serverless，它又能给前端，给 BFF 带来什么新的思路呢？</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-2292170bb4d3dab4419a8b96283f1797_hd.jpg\" alt=\"70% 函数应用\"></p>\n<p>天猪认为是「为<strong>高效地</strong>开发、人机交互界面提供<strong>无感</strong>的服务能力」。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-c01599570a8d54ce3ddb62783f0cc4e6_hd.jpg\" alt=\"SFF\"></p>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*OPqASpxQ5l8AAAAAAAAAAABkARQnAQ\" alt=\"9527 的梗！星爷粉都懂！爱了爱了！\">9527 的梗！星爷粉都懂！爱了爱了！</p>\n<p>天猪 Cue 了经典的「锁不锁版本」的问题，并提到阿里内部对于 Node.js 是不锁版本的，会锁的只是 Runtime 及内部库的版本。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-f921636bf0fab52c808acf92d7e1e31f_hd.jpg\" alt=\"治理能力\"></p>\n<p>值得一提的是，我们 2019 年的花呗双十一落地了 SFF 的首个应用，并成功扛住了猫晚的巨大流量，感谢天猪！</p>\n<h2>云凤蝶可视化搭建的推导与实现</h2>\n<p>这个分享来自蚂蚁金服高级前端工程师 江木 <a href=\"https://www.zhihu.com/people/8c40f1c7236841401327dc36783c12b9\">@paranoidjk</a>，他表示在 SEE Conf 大群潜水的时候，听到有人讨论「早上的分享都在说解放设计师的生产力，为什么没人尝试解放程序员」？</p>\n<p>诶，所以他带着<strong>云凤蝶</strong> lei 了，来解放程序员的生产力了。</p>\n<p>云凤蝶是面向中后台产品的快速研发平台，它运用设计标准化，研发工业化的提效思路，用工业化的方式管理设计资产，</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-3d471e416c4e81d9d173afe99807451d_hd.jpg\" alt=\"云凤蝶是什么\"></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-d959c8356271ee645d6d943b37279c0d_hd.jpg\" alt=\"云凤蝶提效思路\"></p>\n<p>Q&amp;A 环节，有同学问到如何写对应的数据逻辑代码， <a href=\"https://www.zhihu.com/people/9d9f94035b55b89236c232b15c7d9190\">@天猪</a> 做了解答：云凤蝶的能力中有一部分就是 SFF 和 OneAPI 元数据中心支撑的。然后群里就开始了一番老话题的讨论——前端会不会被淘汰，哈哈，你怎么看？</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-d055b7a75de6b29ecde84a84beb72990_hd.jpg\" alt=\"钉钉讨论群\"></p>\n<p>设计场的分享也超棒！在技术场分身乏术呀，等回头看视频，哈哈～</p>\n<h2>蚂蚁海外本地化设计</h2>\n<p>在探索金融产品的出海道路上，蚂蚁国际事业部开拓了印度、菲律宾、马来西亚、巴基斯坦等 10 多个海外市场后，蚂蚁金服高级体验设计专家 竹摇 为我们分享了作为一个中国设计团队为各种不同国家用户设计产品，识别目标用户，识别有价值需求，从 0 到 1 设计有用又好用的产品的过程。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-ccc7f9cadbe494221105e8a411263547_hd.jpg\" alt=\"蚂蚁海外本地化设计\"></p>\n<h2>让价值被发现：如何在 B 端产品做增长</h2>\n<p>蚂蚁体验技术部的设计师 覃一 和 瀚雅 的团队，探索出了面向 B 端产品的增长设计方法和实践：产出增长大图，找到机会点；乘胜追击，举一反三，放大成功影响；在设计中增长，让价值被更多人发现。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-12ffdfd2240300cc545489532909d37b_hd.jpg\" alt=\"让价值被发现\"></p>\n<h2>围绕应用生命周期的企业级产品设计策略</h2>\n<p>当设计师遇上技术产品——高级体验设计师 壹乐 总结了设计师们面临的三大挑战：快速理解并上手业务，找到体验的驱动点和机会点，同时使团队和业务能够互利共生、精诚合作。她希望能通过本次分享启发设计师们找到破局的思路和方法。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-ee9166534521417d1f8a83f77cb73b8c_hd.jpg\" alt=\"围绕应用生命周期的企业级产品设计策略\"></p>\n<h2>普惠金融创新体验：参与感对话设计</h2>\n<p>体验设计专家 姚维 为大家分享了设计师如何通过智能感的设计手段，建立具备专属感的对话方式，解决专业信息传达问题。</p>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*xGozSKfR0q4AAAAAAAAAAABkARQnAQ\" alt=\"普惠金融创新体验\"></p>\n<h2>然后是茶歇～ Tea Time</h2>\n<p>茶歇之后的第一场分享是来自</p>\n<p><a href=\"https://www.zhihu.com/people/b1cce41da90910fb3e359ee8b57c1e2b\">@死马</a></p>\n<p>（不四）的语雀～喜欢语雀的我要认真听！</p>\n<h2>&quot;云&quot;端的语雀 —— 用 JavaScript 全栈打造商业级应用</h2>\n<p>语雀是蚂蚁金服推出的云端知识库，它不仅提供了功能强大的富文本编辑器，还提供了体系化的知识协同与管理能力。</p>\n<p>它最初只是想解决内部没有好用的文档工具的痛点，然后才慢慢做成了文档编辑器，再到现在的云端知识库。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-c3ed1f0dcad2a67f93f1bdd9682fb802_hd.jpg\" alt=\"”云“端的语雀\"></p>\n<p>在语雀的背后，不四团队采用 JavaScript 全栈技术，从零开始一步一步将语雀打造成一个成熟的商业级应用。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-4cad5199eb1eeb7e388d05af226db58b_hd.jpg\" alt=\"语雀的架构演进\"></p>\n<p>最初，它的应用层是学习 Rails 社区的使用大型单体应用承载 Node 应用的思想，使用 CodeMirror 实现 Markdown 编辑器，Bass 层使用公司内部的 BaaS 提供的存储及运行服务（DockerLab）。</p>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*w3eSQ47-DzUAAAAAAAAAAABkARQnAQ\" alt=\"旧架构\"></p>\n<p>后来，演进为下图所示的架构。应用层采用 Monolithic + MicroService 混合架构，将微服务、函数计算上了 Serverless, 同时自研了编辑器：Canvas 实现表格、SVG 实现思维导图、采用开源的 shareDB 实现多人协同能力。至此，语雀整体架构更加稳定可用。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-8e8d5637d3d6797d2b7a6debc281da68_hd.jpg\" alt=\"新架构\"></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-5b02fb54f57a7fa056629f37d6bb2aee_hd.jpg\" alt=\"上 Serverless 的好处\"></p>\n<p>安全性方面他们也做了许多考虑，有许多可以学习借鉴的地方。</p>\n<p>听到他们说双十一还要值班很惊讶，原来是因为必须保障应急文档，不能挂！辛苦了！</p>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*pK-JRIaVZAcAAAAAAAAAAABkARQnAQ\" alt=\"语雀安全性分析\"></p>\n<p>看图片基本能看明白，这里就不展开了，感兴趣的朋友可以看视频回放哈～</p>\n<p>这里附上不四讲的一句话「当你没办法避免强依赖时，你就设法把强依赖变成弱依赖」，这样一旦出问题，你可以 fallback. 你还得全局打日志，出问题时实时感知，也方便做事后分析。</p>\n<h2>蚂蚁金服 Web 3D 技术探索之路</h2>\n<p>接下来是我们 <a href=\"https://zhuanlan.zhihu.com/richlab\">RichLab</a> （花呗借呗前端）团队的分享啦！！！进行分享的是蚂蚁互动小组负责人、我们小组的土豪小哥哥 烧鹅 <a href=\"https://www.zhihu.com/people/bd622f96fbafe2749f1b62e92e0b1944\">@鹅叔</a>。之前专栏写过的同名文章见<a href=\"https://zhuanlan.zhihu.com/p/79026457\">这里</a></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-a1fcd814e7eaec1fded8e5bfa384db4e_hd.jpg\" alt=\"img\">Oasis 3D 负责人 烧鹅</p>\n<p>近些年来，游戏、电影等计算机图形方面的发展已十分成熟，但 Web 端的图形技术才刚刚起步。随着 5G 时代的到来，用户对互联网产品可视化、游戏化的要求将越来越高，更加复杂的 3D 动画、游戏等必然是趋势，我们也在实际业务上见证了它带来的更高增值。</p>\n<p>烧鹅首先介绍了蚂蚁金服几个知名的 Web 3D 项目，哈哈，小鸡登山、星星球——养鸡的小伙伴一定玩过！我们花呗借呗 3D 活动也欢迎大家来玩哟，嘿嘿，动动手机还有陀螺仪效果！</p>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*29EAS6ZTNq8AAAAAAAAAAABkARQnAQ\" alt=\"Web 3D 互动项目\"></p>\n<p>在互联网游戏化的业务背景下，烧鹅团队做了广泛的技术调研，最终决定基于蚂蚁金服亿级用户的金融平台，从 0 到 1 开始 3D 引擎的研发，并结合美术流程和蚂蚁金服的前端研发环境，探索出一条高效低成本的在线工作流—— Oasis.</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-8316bc1e139a926257b13d76e0adb103_hd.jpg\" alt=\"Oasis 3D 引擎\"></p>\n<p>接着，烧鹅介绍了 Oasis 3D 引擎和配套工作流的设计思路。Oasis 不仅满足了互动营销业务场景的需求，而且为工业产品展示、数据可视化等业务场景提供了可靠的渲染能力，在实际的项目落地上，它也支撑了历年双十一的大促互动项目。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-b0e12554e3d12747cd202d23d08e362e_hd.jpg\" alt=\"仅有 3D 引擎就够了吗？\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-edd9cb67396cedcdbd01a7d58cb34d9b_hd.jpg\" alt=\"Oasis 工作流\"></p>\n<p>想了解如何用 Oasis 开发 3D 游戏吗？我们也贴心地为你送上<a href=\"https://zhuanlan.zhihu.com/p/101031981\">从借呗双十一游戏看蚂蚁金服 Oasis 3D 工作流</a>教程文章。</p>\n<p>最后，他站在前端工程师的角度思考了 3D 在 Web 世界能够发挥的场景。</p>\n<p>比如打通 AR 眼镜生态，让 AR 更触手可及。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-adb553e7b962ca400698ca6a5925061a_hd.jpg\" alt=\"打通 AR 眼镜生态\"></p>\n<p>还有和<strong>阿里巴巴达摩院</strong>合作的手势交互场景，想想就很有趣！</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-f56816d2786ac453e9198dde04f9bd76_hd.jpg\" alt=\"手势计算辅助 3D 交互\"></p>\n<p>最后，少不了对未来的展望啦～相信在烧鹅团队的努力下，这些目标将一个个地实现！</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-c639b6fd7922cdaa9ac8b1e407243a92_hd.jpg\" alt=\"长远目标\"></p>\n<p>除了 Oasis 之外，我们团队还维护了 Ant Design 的弟弟—— Ant Design Mobile 项目、 Rococo 搭建与投放平台以及 Bakery 一站式产品演示平台。此外，我们在数据智能化运营、Serverless、工程化、基于浏览器的构建技术等技术领域也有涉猎。</p>\n<p><strong>嘿嘿嘿，如果你想与我们更进一步交流，欢迎直接联系我喔！(′▽`〃) 团队现在也有好多 HC! 欢迎来和我一起工作鸭！！</strong></p>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*enQES7QfU9cAAAAAAAAAAABkARQnAQ\" alt=\"乱入一个我\">乱入一个我</p>\n<h2>精雕细琢，打造极致可视化体验</h2>\n<p>压轴出场的，是蚂蚁金服高级前端工程师、AntV 核心贡献者 逍为。</p>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*Ad3dTbUL2VYAAAAAAAAAAABkARQnAQ\" alt=\"逍为\"></p>\n<p>逍为团队在开发 DeepInsight 数据洞察分析平台的时候，经历了大量用户吐槽可视化图表体验问题。后来，他们决定将可视化换成自研的 AntV, 精雕细琢，一步一步的打磨可视化图表的体验，并提出新目标、新架构、新产品来达成这一目标；在这个过程中产生的所有体验优化成果，都将在 G2Plot 这个开源产品中一览无遗。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-0bd1e4d1236f2192ac76d9ab8761e8fd_hd.jpg\" alt=\"逍为\"></p>\n<p>相信在可视化/BI 领域的同学，都能在图表体验问题上产生共鸣！！</p>\n<p>与此同时，可视化工作坊以及设计场也在如火如荼地进行中～</p>\n<h2>可视化工作坊</h2>\n<p>此次工作坊围绕数据、图表展示如何用故事化的设计思维与方法进行可视化的体验设计，同时提供真实应用场景练习如何去探析数据背后的洞察。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-815ab3f8fd56cb3434e952b31ab75637_hd.jpg\" alt=\"工作坊形式：张贴、陈述、投票\">工作坊形式：张贴、陈述、投票</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-09efb02e3aa4863683ba148a45c81eaf_hd.jpg\" alt=\"认真作画的小伙伴们\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-df69535d8af96d62b79ce2c14b01da79_hd.jpg\" alt=\"认真作画的小伙伴们\">认真作画的小伙伴们</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-ea45b82b73d2d44d12c45251b3d66e26_hd.jpg\" alt=\"设计师讲述自己的创作\">设计师讲述自己的创作</p>\n<p>嘿嘿，我为大家找到了**<a href=\"https://zhuanlan.zhihu.com/p/101095747\">可视化工作坊的独家揭秘</a>**文章！赶紧学习起来～</p>\n<p>设计场讲了些什么呢？</p>\n<h2>JCD 思维如何驱动复杂系统设计</h2>\n<p>基于蚂蚁金服 CTO 线的业务土壤，体验技术部的设计师们通过不断打磨，尝试以 JCD (Job Centered Design) 为核心的设计思维，探索出用户和业务的分析模型，让设计师在面对复杂业务时有方法可借鉴，使整个设计效率提升了 100%。</p>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*C5PQR7Q0t0EAAAAAAAAAAABkARQnAQ\" alt=\"JCD 思维如何驱动复杂系统设计\"></p>\n<h2>资产的秩序之美：通过模式化的方法构建设计资产的内在一致性</h2>\n<p>高级体验设计师 吾笙 希望通过此次分享启发大家探索如何制定全局的约束型规则，如何构建底层的设计逻辑，如何制定约束的设计规则，最大化保证其在各个业务场景下的适应性。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-3e14f1b8ee4cb43bc331093972a98a99_hd.jpg\" alt=\"吾笙\"></p>\n<h2>解放图形化设计生产力 — HiTu</h2>\n<p>设计场的压轴专业分享，来自早上主会场的高级创意设计师 线丝，这次，他详细介绍了由蚂蚁金服体验技术部出品的解放图形化设计生产力工具 —— HiTu. HiTu 能做些什么呢，让<a href=\"https://zhuanlan.zhihu.com/p/100925117\">这篇文章</a>告诉你～～</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-8d973a5f6baf8f15cb14aa4c11ec6d86_hd.jpg\" alt=\"线丝\"></p>\n<p>至此，第三届 SEE Conf 也圆满落下帷幕，希望大家无论是设计师还是工程师，都能满载而归，哈哈！</p>\n<h2>最后！！偷偷告诉你：据说参与知乎讨论，有机会赢取下一届 SEE Conf 的免费全天门票喔！！冲鸭！！</h2>\n<p>PS：</p>\n<ul>\n<li>T T 好喜欢这个小鸡！可惜中午过去的时候就被告知送完收摊了。。哭哭</li>\n</ul>\n<p><img src=\"https://gw.alipayobjects.com/mdn/rms_4b03c4/afts/img/A*Aw0dS5AyQhcAAAAAAAAAAABkARQnAQ\" alt=\"蚂蚁庄园搪瓷小鸡\"></p>\n<ul>\n<li>展台成品好丰富呀～</li>\n</ul>\n<p><img src=\"https://pic2.zhimg.com/80/v2-d39de17d89ad2eb85173ffdea377265b_hd.jpg\" alt=\"参会者们用 Ant Design 资产设计的网页\">参会者们用 Ant Design 资产设计的网页</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-b6cf39ebdcedfd82d2867fb031060861_hd.jpg\" alt=\"AntV 行为艺术\">AntV 行为艺术</p>\n</div>",
            "title": "第三届 SEE Conf 全天场图文回顾，围观玉伯、天猪、死马都讲了啥！",
            "last_reply_at": "2020-03-14T08:31:22.162Z",
            "good": false,
            "top": true,
            "reply_count": 8,
            "visit_count": 18017,
            "create_at": "2020-01-08T03:33:15.648Z",
            "author": {
                "loginname": "jothy1023",
                "avatar_url": "https://avatars2.githubusercontent.com/u/14975630?v=4&s=120"
            }
        },
        {
            "id": "5e58b0bb1225c9423dcdb3d7",
            "author_id": "5e58b0571225c9423dcdb3d1",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>用过js,想转ts,不知道会不会有问题,两者可以结合吗</p>\n</div>",
            "title": "大佬们问个问题,nodejs用ts开发后端如何",
            "last_reply_at": "2020-04-09T08:21:02.350Z",
            "good": false,
            "top": false,
            "reply_count": 24,
            "visit_count": 3758,
            "create_at": "2020-02-28T06:18:35.317Z",
            "author": {
                "loginname": "17723010593",
                "avatar_url": "https://avatars3.githubusercontent.com/u/59968345?v=4&s=120"
            }
        },
        {
            "id": "5e8d3a9064259617c49a4d22",
            "author_id": "550973933135610a365b01fa",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/banner-rmc-compare.png\" alt></p>\n<p><strong><a href=\"https://github.com/concentjs/concent\">❤ star me if you like concent ^_^</a></strong></p>\n<h2>序言</h2>\n<p><code>redux</code>、<code>mobx</code>本身是一个独立的状态管理框架，各自有自己的抽象api，以其他UI框架无关（react, vue…），本文主要说的和<code>react</code>搭配使用的对比效果，所以下文里提到的<code>redux</code>、<code>mobx</code>暗含了<code>react-redux</code>、<code>mobx-react</code>这些让它们能够在<code>react</code>中发挥功能的绑定库，而<code>concent</code>本身是为了<code>react</code>贴身打造的开发框架，数据流管理只是作为其中一项功能，附带的其他增强react开发体验的特性可以按需使用，后期会刨去<code>concent</code>里所有与<code>react</code>相关联的部分发布<code>concent-core</code>，它的定位才是与<code>redux</code>、<code>mobx</code> 相似的。</p>\n<p>所以其实将在本文里登场的选手分别是</p>\n<h3>redux &amp; react-redux</h3>\n<ul>\n<li>\n<p>slogan<br>\nJavaScript 状态容器，提供可预测化的状态管理</p>\n</li>\n<li>\n<p>设计理念<br>\n单一数据源，使用纯函数修改状态</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/1.png\" alt></p>\n<h3>mobx &amp; mobx-react</h3>\n<ul>\n<li>\n<p>slogan：<br>\n简单、可扩展的状态管理</p>\n</li>\n<li>\n<p>设计理念<br>\n任何可以从应用程序状态派生的内容都应该派生</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/2.png\" alt></p>\n<h3>concent</h3>\n<ul>\n<li>\n<p>slogan：<br>\n可预测、0入侵、渐进式、高性能的react开发方案</p>\n</li>\n<li>\n<p>设计理念<br>\n相信融合不可变+依赖收集的开发方式是react的未来，增强react组件特性，写得更少，做得更多。</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/3.png\" alt></p>\n<p>介绍完三者的背景，我们的舞台正式交给它们，开始一轮轮角逐，看谁到最后会是你最中意的范儿？</p>\n<h3>结果预览</h3>\n<p>以下5个较量回合实战演示代码较多，此处将对比结果提前告知，方便粗读看客可以快速了解。</p>\n<table>\n<thead>\n<tr>\n<th>store配置</th>\n<th>concent</th>\n<th>mbox</th>\n<th>redux</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>支持分离</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>无根Provider &amp; 使用处无需显式导入</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>reducer无<code>this</code></td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>store数据或方法无需人工映射到组件</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n<p><strong><a href=\"https://codesandbox.io/s/redux-counter-2mk1g\">redux counter示例</a></strong><br>\n<strong><a href=\"https://codesandbox.io/s/counter-mobx-9kt50\">mobx counter示例</a></strong><br>\n<strong><a href=\"https://codesandbox.io/s/concent-counter-y61if\">concent counter示例</a></strong></p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>状态修改</th>\n<th>concent</th>\n<th>mbox</th>\n<th>redux</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基于不可变原则</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>最短链路</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>ui源头可追踪</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>无this</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>原子拆分&amp;合并提交</td>\n<td>Yes(基于lazy)</td>\n<td>Yes(基于transaction)</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<table>\n<thead>\n<tr>\n<th>依赖收集</th>\n<th>concent</th>\n<th>mbox</th>\n<th>redux</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>支持运行时收集依赖</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>精准渲染</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>无this</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>只需一个api介入</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n<p><strong><a href=\"https://codesandbox.io/s/concent-login-ylbl4\">mobx 示例</a></strong><br>\n<strong><a href=\"https://codesandbox.io/s/concent-login-ylbl4\">concent 示例</a></strong></p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>衍生数据</th>\n<th>concent</th>\n<th>mbox</th>\n<th>redux(reselect)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>自动维护计算结果之间的依赖</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>触发读取计算结果时收集依赖</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>计算函数无this</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n</tbody>\n</table>\n<p><strong><a href=\"https://codesandbox.io/s/redux-login-6uqg8\">redux computed示例</a></strong><br>\n<strong><a href=\"https://codesandbox.io/s/concent-login-ylbl4\">mobx computed示例</a></strong><br>\n<strong><a href=\"https://codesandbox.io/s/concent-login-ylbl4\">concent computed示例</a></strong></p>\n<hr>\n<p>todo-mvc实战<br>\n<strong><a href=\"https://codesandbox.io/s/todo-mvc-redux-49kg0\">redux todo-mvc</a></strong><br>\n<strong><a href=\"https://codesandbox.io/s/todo-mvc-mbox-k42q1\">mobx todo-mvc</a></strong><br>\n<strong><a href=\"https://codesandbox.io/s/todoapp-react-concent-fvgvc\">concent todo-mvc</a></strong></p>\n<h2>round 1 - 代码风格初体验</h2>\n<p>counter作为demo界的靓仔被无数次推上舞台，这一次我们依然不例外，来个counter体验3个框架的开发套路是怎样的，以下3个版本都使用<code>create-react-app</code>创建，并以<strong>多模块的方式</strong>来组织代码，力求接近真实环境的代码场景。</p>\n<h3>redux(action、reducer)</h3>\n<p>通过<code>models</code>把按模块把功能拆到不同的reducer里，目录结构如下</p>\n<pre class=\"prettyprint\"><code>|____models             # business models\n| |____index.js         # 暴露store\n| |____counter          # counter模块相关的action、reducer\n| | |____action.js     \n| | |____reducer.js     \n| |____ ...             # 其他模块\n|____CounterCls         # 类组件\n|____CounterFn          # 函数组件\n|____index.js           # 应用入口文件\n</code></pre><blockquote>\n<p>此处仅与redux的原始模板组织代码，实际情况可能不少开发者选择了<code>rematch</code>，<code>dva</code>等基于redux做二次封装并改进写法的框架，但是并不妨碍我们理解counter实例。</p>\n</blockquote>\n<p>构造counter的<code>action</code></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; code in models&#x2F;counter&#x2F;action\nexport const INCREMENT = &quot;INCREMENT&quot;;\n\nexport const DECREMENT = &quot;DECREMENT&quot;;\n\nexport const increase = number =&gt; {\n  return { type: INCREMENT, payload: number };\n};\n\nexport const decrease = number =&gt; {\n  return {  type: DECREMENT, payload: number };\n};\n</code></pre><p>构造counter的<code>reducer</code></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; code in models&#x2F;counter&#x2F;reducer\nimport { INCREMENT, DECREMENT } from &quot;.&#x2F;action&quot;;\n\nexport default (state = { count: 0 }, action) =&gt; {\n  const { type, payload } = action;\n  switch (type) {\n    case INCREMENT:\n      return { ...state, count: state.count + payload };\n    case DECREMENT:\n      return { ...state, count: state.count - payload };\n    default:\n      return state;\n  }\n};\n\n</code></pre><p>合并<code>reducer</code>构造<code>store</code>，并注入到根组件</p>\n<pre class=\"prettyprint language-jsx\"><code>mport { createStore, combineReducers } from &quot;redux&quot;;\nimport  countReducer  from &quot;.&#x2F;models&#x2F;counter&#x2F;reducer&quot;;\n\nconst store = createStore(combineReducers({counter:countReducer}));\n\nReactDOM.render(\n  &lt;Provider store={store}&gt;\n    &lt;App &#x2F;&gt;\n  &lt;&#x2F;Provider&gt;,\n  document.getElementById(&quot;root&quot;)\n);\n</code></pre><p>使用connect连接ui与<code>store</code></p>\n<pre class=\"prettyprint language-jsx\"><code>import React from &quot;react&quot;;\nimport { connect } from &quot;react-redux&quot;;\nimport { increase, decrease } from &quot;.&#x2F;redux&#x2F;action&quot;;\n\n@connect(\n  state =&gt; ({ count: state.counter.count }),&#x2F;&#x2F; mapStateToProps\n  dispatch =&gt; ({&#x2F;&#x2F; mapDispatchToProps\n    increase: () =&gt; dispatch(increase(1)),\n    decrease: () =&gt; dispatch(decrease(1))\n  }),\n)\nclass Counter extends React.Component {\n  render() {\n    const { count, increase, decrease } = this.props;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Count : {count}&lt;&#x2F;h1&gt;\n        &lt;button onClick={increase}&gt;Increase&lt;&#x2F;button&gt;\n        &lt;button onClick={decrease}&gt;decrease&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  }\n}\n\nexport default Counter;\n</code></pre><p>上面的示例书写了一个类组件，而针对现在火热的<code>hook</code>，<code>redux v7</code>也发布了相应的api<code>useSelector</code>、<code>useDispatch</code></p>\n<pre class=\"prettyprint language-jsx\"><code>import * as React from &quot;react&quot;;\nimport { useSelector, useDispatch } from &quot;react-redux&quot;;\nimport * as counterAction from &quot;models&#x2F;counter&#x2F;action&quot;;\n\nconst Counter = () =&gt; {\n  const count = useSelector(state =&gt; state.counter.count);\n  const dispatch = useDispatch();\n  const increase = () =&gt; dispatch(counterAction.increase(1));\n  const decrease = () =&gt; dispatch(counterAction.decrease(1));\n\n  return (\n    &lt;&gt;\n      &lt;h1&gt;Fn Count : {count}&lt;&#x2F;h1&gt;\n      &lt;button onClick={increase}&gt;Increase&lt;&#x2F;button&gt;\n      &lt;button onClick={decrease}&gt;decrease&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n};\n\nexport default Counter;\n</code></pre><p>渲染这两个counter，<strong><a href=\"https://codesandbox.io/s/redux-counter-2mk1g\">查看redux示例</a></strong></p>\n<pre class=\"prettyprint language-jsx\"><code>function App() {\n  return (\n      &lt;div className=&quot;App&quot;&gt;\n        &lt;CounterCls&#x2F;&gt;\n        &lt;CounterFn&#x2F;&gt;\n      &lt;&#x2F;div&gt;\n  );\n}\n</code></pre><h3>mobx(store, inject)</h3>\n<p>当应用存在多个store时(这里我们可以把一个store理解成redux里的一个reducer块，聚合了数据、衍生数据、修改行为)，mobx的store获取方式有多种，例如在需要用的地方直接引入放到成员变量上</p>\n<pre class=\"prettyprint language-js\"><code>import someStore from &#x27;models&#x2F;foo&#x27;;&#x2F;&#x2F; 是一个已经实例化的store实例\n\n@observer\nclass Comp extends React.Component{\n    foo = someStore;\n    render(){\n        this.foo.callFn();&#x2F;&#x2F;调方法\n        const text = this.foo.text;&#x2F;&#x2F;取数据\n    }\n}\n</code></pre><p>我们此处则按照公认的最佳实践来做，即把所有store合成一个根store挂到Provider上，并将Provider包裹整个应用根组件，在使用的地方标记<code>inject</code>装饰器即可，我们的目录结构最终如下，和<code>redux</code>版本并无区别</p>\n<pre class=\"prettyprint\"><code>|____models             # business models\n| |____index.js         # 暴露store\n| |____counter          # counter模块相关的store\n| | |____store.js     \n| |____ ...             # 其他模块\n|____CounterCls         # 类组件\n|____CounterFn          # 函数组件\n|____index.js           # 应用入口文件\n</code></pre><p>构造counter的<code>store</code></p>\n<pre class=\"prettyprint language-js\"><code>import { observable, action, computed } from &quot;mobx&quot;;\n\nclass CounterStore {\n  @observable\n  count = 0;\n\n  @action.bound\n  increment() {\n    this.count++;\n  }\n\n  @action.bound\n  decrement() {\n    this.count--;\n  }\n}\n\nexport default new CounterStore();\n</code></pre><p>合并所有<code>store</code>为<code>根store</code>，并注入到根组件</p>\n<pre class=\"prettyprint language-jsx\"><code>&#x2F;&#x2F; code in models&#x2F;index.js\nimport counter from &#x27;.&#x2F;counter&#x27;;\nimport login from &#x27;.&#x2F;login&#x27;;\n\nexport default {\n  counter,\n  login,\n}\n\n&#x2F;&#x2F; code in index.js\nimport React, { Component } from &quot;react&quot;;\nimport { render } from &quot;react-dom&quot;;\nimport { Provider } from &quot;mobx-react&quot;;\nimport store from &quot;.&#x2F;models&quot;;\nimport CounterCls from &quot;.&#x2F;CounterCls&quot;;\nimport CounterFn from &quot;.&#x2F;CounterFn&quot;;\n\nrender(    \n    &lt;Provider store={store}&gt;\n      &lt;App &#x2F;&gt;\n    &lt;&#x2F;Provider&gt;, \n    document.getElementById(&quot;root&quot;)\n);\n</code></pre><p>创建一个类组件</p>\n<pre class=\"prettyprint language-jsx\"><code>import React, { Component } from &quot;react&quot;;\nimport { observer, inject } from &quot;mobx-react&quot;;\n\n@inject(&quot;store&quot;)\n@observer\nclass CounterCls extends Component {\n  render() {\n    const counter = this.props.store.counter;\n    return (\n      &lt;div&gt;\n        &lt;div&gt; class Counter {counter.count}&lt;&#x2F;div&gt;\n        &lt;button onClick={counter.increment}&gt;+&lt;&#x2F;button&gt;\n        &lt;button onClick={counter.decrement}&gt;-&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  }\n}\n\nexport default CounterCls;\n</code></pre><p>创建一个函数组件</p>\n<pre class=\"prettyprint language-jsx\"><code>import React from &quot;react&quot;;\nimport { useObserver, observer } from &quot;mobx-react&quot;;\nimport store from &quot;.&#x2F;models&quot;;\n\nconst CounterFn = () =&gt; {\n  const { counter } = store;\n  return useObserver(() =&gt; (\n      &lt;div&gt;\n        &lt;div&gt; class Counter {counter.count}&lt;&#x2F;div&gt;\n        &lt;button onClick={counter.increment}&gt;++&lt;&#x2F;button&gt;\n        &lt;button onClick={counter.decrement}&gt;--&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n  ));\n};\n\nexport default CounterFn;\n</code></pre><p>渲染这两个counter，<strong><a href=\"https://codesandbox.io/s/counter-mobx-9kt50\">查看mobx示例</a></strong></p>\n<pre class=\"prettyprint language-jsx\"><code>function App() {\n  return (\n      &lt;div className=&quot;App&quot;&gt;\n        &lt;CounterCls&#x2F;&gt;\n        &lt;CounterFn&#x2F;&gt;\n      &lt;&#x2F;div&gt;\n  );\n}\n</code></pre><h3>concent(reducer, register)</h3>\n<p>concent和redux一样，存在一个全局单一的根状态<code>RootStore</code>，该根状态下第一层key用来当做模块命名空间，concent的一个模块必需配置<code>state</code>，剩下的<code>reducer</code>、<code>computed</code>、<code>watch</code>、<code>init</code>是可选项，可以按需配置，如果把store所有模块写到一处，最简版本的<code>concent</code>示例如下</p>\n<pre class=\"prettyprint language-js\"><code>import { run, setState, getState, dispatch } from &#x27;concent&#x27;;\nrun({\n    counter:{&#x2F;&#x2F; 配置counter模块\n        state: { count: 0 }, &#x2F;&#x2F; 【必需】定义初始状态, 也可写为函数 ()=&gt;({count:0})\n        &#x2F;&#x2F; reducer: { ...}, &#x2F;&#x2F; 【可选】修改状态的方法\n        &#x2F;&#x2F; computed: { ...}, &#x2F;&#x2F; 【可选】计算函数\n        &#x2F;&#x2F; watch: { ...}, &#x2F;&#x2F; 【可选】观察函数\n        &#x2F;&#x2F; init: { ...}, &#x2F;&#x2F; 【可选】异步初始化状态函数\n    }\n})；\n\nconst count = getState(&#x27;counter&#x27;).count;&#x2F;&#x2F; count is: 0\n&#x2F;&#x2F; count is: 1，如果有组件属于该模块则会被触发重渲染\nsetState(&#x27;counter&#x27;, {count:count + 1});\n\n&#x2F;&#x2F; 如果定义了counter.reducer下定义了changeCount方法\n&#x2F;&#x2F; dispatch(&#x27;counter&#x2F;changeCount&#x27;)\n</code></pre><p>启动<code>concent</code>载入store后，可在其它任意类组件或函数组件里注册其属于于某个指定模块或者连接多个模块</p>\n<pre class=\"prettyprint language-jsx\"><code>import { useConcent, register } from &#x27;concent&#x27;;\n\nfunction FnComp(){\n    const { state, setState, dispatch } = useConcent(&#x27;counter&#x27;);\n    &#x2F;&#x2F; return ui ...\n}\n\n@register(&#x27;counter&#x27;)\nclass ClassComp extends React.Component(){\n    render(){\n        const { state, setState, dispatch } = this.ctx;\n        &#x2F;&#x2F; return ui ...\n    }\n}\n</code></pre><p>但是推荐将模块定义选项放置到各个文件中，以达到职责分明、关注点分离的效果，所以针对counter，目录结构如下</p>\n<pre class=\"prettyprint\"><code>|____models             # business models\n| |____index.js         # 配置store各个模块\n| |____counter          # counter模块相关\n| | |____state.js       # 状态\n| | |____reducer.js     # 修改状态的函数\n| | |____index.js       # 暴露counter模块\n| |____ ...             # 其他模块\n|____CounterCls         # 类组件\n|____CounterFn          # 函数组件\n|____index.js           # 应用入口文件\n|____runConcent.js      # 启动concent \n</code></pre><p>构造counter的<code>state</code>和<code>reducer</code></p>\n<pre class=\"prettyprint language-jsx\"><code>&#x2F;&#x2F; code in models&#x2F;counter&#x2F;state.js\nexport default {\n  count: 0,\n}\n\n&#x2F;&#x2F; code in models&#x2F;counter&#x2F;reducer.js\nexport function increase(count, moduleState) {\n  return { count: moduleState.count + count };\n}\n\nexport function decrease(count, moduleState) {\n  return { count: moduleState.count - count };\n}\n</code></pre><p>两种方式配置store</p>\n<ul>\n<li>配置在run函数里</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>import counter from &#x27;models&#x2F;counter&#x27;;\n\nrun({counter});\n</code></pre><ul>\n<li>通过<code>configure</code>接口配置, <code>run</code>接口只负责启动concent</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; code in runConcent.js\nimport { run } from &#x27;concent&#x27;;\nrun();\n\n&#x2F;&#x2F; code in models&#x2F;counter&#x2F;index.js\nimport state from &#x27;.&#x2F;state&#x27;;\nimport * as reducer from &#x27;.&#x2F;reducer&#x27;;\nimport { configure } from &#x27;concent&#x27;;\n\nconfigure(&#x27;counter&#x27;, {state, reducer});&#x2F;&#x2F; 配置counter模块\n</code></pre><p>创建一个函数组件</p>\n<pre class=\"prettyprint language-jsx\"><code>import * as React from &quot;react&quot;;\nimport { useConcent } from &quot;concent&quot;;\n\nconst Counter = () =&gt; {\n  const { state, dispatch } = useConcent(&quot;counter&quot;);\n  const increase = () =&gt; dispatch(&quot;increase&quot;, 1);\n  const decrease = () =&gt; dispatch(&quot;decrease&quot;, 1);\n\n  return (\n    &lt;&gt;\n      &lt;h1&gt;Fn Count : {state.count}&lt;&#x2F;h1&gt;\n      &lt;button onClick={increase}&gt;Increase&lt;&#x2F;button&gt;\n      &lt;button onClick={decrease}&gt;decrease&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n};\n\nexport default Counter;\n</code></pre><p>该函数组件我们是按照传统的<code>hook</code>风格来写，即每次渲染执行<code>hook</code>函数，利用<code>hook</code>函数返回的基础接口再次定义符合当前业务需求的动作函数。</p>\n<p>但是由于concent提供<code>setup</code>接口，我们可以利用它只会在初始渲染前执行一次的能力，将这些动作函数放置到<code>setup</code>内部定义为静态函数，避免重复定义，所以一个更好的函数组件应为</p>\n<pre class=\"prettyprint language-jsx\"><code>import * as React from &quot;react&quot;;\nimport { useConcent } from &quot;concent&quot;;\n\nexport const setup = ctx =&gt; {\n  return {\n    &#x2F;&#x2F; better than ctx.dispatch(&#x27;increase&#x27;, 1);\n    increase: () =&gt; ctx.moduleReducer.increase(1),\n    decrease: () =&gt; ctx.moduleReducer.decrease(1)\n  };\n};\n\nconst CounterBetter = () =&gt; {\n  const { state, settings } = useConcent({ module: &quot;counter&quot;, setup });\n  const { increase, decrease } = settings;\n  &#x2F;&#x2F; return ui...\n};\n\nexport default CounterBetter;\n\n</code></pre><p>创建一个类组件，复用<code>setup</code>里的逻辑</p>\n<pre class=\"prettyprint language-jsx\"><code>import React from &quot;react&quot;;\nimport { register } from &quot;concent&quot;;\nimport { setup } from &#x27;.&#x2F;CounterFn&#x27;;\n\n@register({module:&#x27;counter&#x27;, setup})\nclass Counter extends React.Component {\n  render() {\n    &#x2F;&#x2F; this.state 和 this.ctx.state 取值效果是一样的\n    const { state, settings } = this.ctx;\n     &#x2F;&#x2F; return ui...\n  }\n}\n\nexport default Counter;\n</code></pre><p>渲染这两个counter，<strong><a href=\"https://codesandbox.io/s/concent-counter-y61if\">查看concent示例</a></strong></p>\n<pre class=\"prettyprint language-jsx\"><code>function App() {\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;CounterCls &#x2F;&gt;\n      &lt;CounterFn &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n}\n</code></pre><h3>回顾与总结</h3>\n<p>此回合里展示了3个框架对定义多模块状态时，不同的代码组织与结构</p>\n<ul>\n<li><code>redux</code>通过<code>combineReducers</code>配合<code>Provider</code>包裹根组件，同时还收手写<code>mapStateToProps</code>和<code>mapActionToProps</code>来辅助组件获取store的数据和方法</li>\n<li><code>mobx</code>通过合并多个<code>subStore</code>到一个<code>store</code>对象并配合<code>Provider</code>包裹根组件，store的数据和方法可直接获取</li>\n<li><code>concent</code>通过<code>run</code>接口集中配置或者<code>configure</code>接口分离式的配置，store的数据和方法可直接获取</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>store配置</th>\n<th>concent</th>\n<th>mbox</th>\n<th>redux</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>支持分离</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>无根Provider &amp; 使用处无需显式导入</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>reducer无<code>this</code></td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>store数据或方法无需人工映射到组件</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n<h2>round 2 - 状态修改</h2>\n<p>3个框架对状态的修改风格差异较大。\n<code>redux</code>里严格限制状态修改途径，所以的修改状态行为都必须派发<code>action</code>，然后命中相应<code>reducer</code>合成新的状态。</p>\n<p><code>mobx</code>具有响应式的能力，直接修改即可，但因此也带来了数据修改途径不可追溯的烦恼从而产生了<code>mobx-state-tree</code>来配套约束修改数据行为。</p>\n<p><code>concent</code>的修改完完全全遵循<code>react</code>的修改入口<code>setState</code>风格，在此基础之上进而封装<code>dispatch</code>、<code>invoke</code>、<code>sync</code>系列api，且无论是调用哪一种api，都能够不只是追溯数据修改完整链路，还包括触发数据修改的源头。</p>\n<h3>redux(dispatch)</h3>\n<p>同步的action</p>\n<pre class=\"prettyprint language-js\"><code>export const changeFirstName = firstName =&gt; {\n  return {\n    type: CHANGE_FIRST_NAME,\n    payload: firstName\n  };\n};\n</code></pre><p>异步的action，借助<code>redux-thunk</code>来完成</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; code in models&#x2F;index.js, 配置thunk中间件\nimport  thunk  from &quot;redux-thunk&quot;;\nimport { createStore, combineReducers, applyMiddleware } from &quot;redux&quot;;\nconst store = createStore(combineReducers({...}), applyMiddleware(thunk));\n\n&#x2F;&#x2F; code in models&#x2F;login&#x2F;action.js\nexport const CHANGE_FIRST_NAME = &quot;CHANGE_FIRST_NAME&quot;;\n\nconst delay = (ms = 1000) =&gt; new Promise(r =&gt; setTimeout(r, ms));\n&#x2F;&#x2F; 工具函数，辅助写异步action\nconst asyncAction = asyncFn =&gt; {\n  return dispatch =&gt; {\n    asyncFn(dispatch).then(ret =&gt; {\n      if(ret){\n        const [type, payload] = ret;\n        dispatch({ type, payload });\n      }\n    }).catch(err=&gt;alert(err));\n  };\n};\n\nexport const asyncChangeFirstName = firstName =&gt; {\n  return asyncAction(async (dispatch) =&gt; {&#x2F;&#x2F;可用于中间过程多次dispatch\n    await delay();\n    return [CHANGE_FIRST_NAME, firstName];\n  });\n};\n</code></pre><h3>mobx版本(<a href=\"http://this.XXX\">this.XXX</a>)</h3>\n<p>同步action与异步action</p>\n<pre class=\"prettyprint language-js\"><code>import { observable, action, computed } from &quot;mobx&quot;;\n\nconst delay = (ms = 1000) =&gt; new Promise(r =&gt; setTimeout(r, ms));\n\nclass LoginStore {\n  @observable firstName = &quot;&quot;;\n\n  @observable lastName = &quot;&quot;;\n\n  @action.bound\n  changeFirstName(firstName) {\n    this.firstName = firstName;\n  }\n\n  @action.bound\n  async asyncChangeFirstName(firstName) {\n    await delay();\n    this.firstName = firstName;\n  }\n\n  @action.bound\n  changeLastName(lastName) {\n    this.lastName = lastName;\n  }\n}\n\nexport default new LoginStore();\n</code></pre><p>直接修改</p>\n<pre class=\"prettyprint language-js\"><code>const LoginFn = () =&gt; {\n  const { login } = store;\n  const changeFirstName = e =&gt; login.firstName = e.target.value;\n  &#x2F;&#x2F; ...    \n}\n</code></pre><p>通过action修改</p>\n<pre class=\"prettyprint language-js\"><code>const LoginFn = () =&gt; {\n  const { login } = store;\n  const const changeFirstName = e =&gt; login.changeFirstName(e.target.value);\n  &#x2F;&#x2F; ...    \n}\n</code></pre><h3>concent(dispatch,setState,invoke,sync)</h3>\n<p>concent里不再区分<code>action</code>和<code>reducer</code>，ui直接调用<code>reducer</code>方法即可，同时<code>reducer</code>方法可以是同步也可以是异步，支持相互任意组合和lazy调用，大大减轻开发者的心智负担。</p>\n<p>同步<code>reducer</code>与异步<code>reducer</code></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; code in models&#x2F;login&#x2F;reducer.js\nconst delay = (ms = 1000) =&gt; new Promise(r =&gt; setTimeout(r, ms));\n\nexport function changeFirstName(firstName) {\n  return { firstName };\n}\n\nexport async function asyncChangeFirstName(firstName) {\n  await delay();\n  return { firstName };\n}\n\nexport function changeLastName(lastName) {\n  return { lastName };\n}\n</code></pre><p>可任意组合的reducer，属于同一个模块内的方法可以直接基于方法引用调用，且reducer函数并非强制一定要返回一个新的片断状态，仅用于组合其他reducer也是可以的。</p>\n<pre class=\"prettyprint language-jsx\"><code>&#x2F;&#x2F; reducerFn(payload:any, moduleState:{}, actionCtx:IActionCtx)\n&#x2F;&#x2F; 当lazy调用此函数时，任何一个函数出错了，中间过程产生的所有状态都不会提交到store\nexport async changeFirstNameAndLastName([firstName, lastName], m, ac){\n    await ac.dispatch(changeFirstName, firstName);\n    await ac.dispatch(changeFirstName, lastName);\n    &#x2F;&#x2F; return {someNew:&#x27;xxx&#x27;};&#x2F;&#x2F;可选择此reducer也返回新的片断状态\n}\n\n&#x2F;&#x2F; 视图处\nfunction UI(){\n    const ctx useConcent(&#x27;login&#x27;);\n    &#x2F;&#x2F; 触发两次渲染\n    const normalCall = ()=&gt;ctx.mr.changeFirstNameAndLastName([&#x27;first&#x27;, &#x27;last&#x27;]);\n    &#x2F;&#x2F; 触发一次渲染\n    const lazyCall = ()=&gt;ctx.mr.changeFirstNameAndLastName([&#x27;first&#x27;, &#x27;last&#x27;], {lazy:true});\n    \n    return (\n        &lt;&gt;\n            &lt;button onClick={handleClick}&gt; normalCall &lt;&#x2F;button&gt;\n            &lt;button onClick={handleClick}&gt; lazyCall &lt;&#x2F;button&gt;\n        &lt;&#x2F;&gt;\n    )\n}\n</code></pre><p><strong><a href=\"https://stackblitz.com/edit/concent-lazy-dispatch\">lazyReducer示例</a></strong></p>\n<p>非lazy调用流程</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/4.png\" alt></p>\n<p>lazy调用流程</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/5.png\" alt></p>\n<p>当然了，除了<code>reducer</code>，其他3种方式都可以任意搭配，且和<code>reducer</code>一样拥有同步状态到其他属于同一个模块且对某状态有依赖的实例上</p>\n<ul>\n<li>setState</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function FnUI(){\n    const {setState} = useConcent(&#x27;login&#x27;);\n    const changeName = e=&gt; setState({firstName:e.target.name});\n    &#x2F;&#x2F; ... return ui\n}\n\n@register(&#x27;login&#x27;)\nclass ClsUI extends React.Component{\n    changeName = e=&gt; this.setState({firstName:e.target.name})\n    render(){...}\n}\n</code></pre><ul>\n<li>invoke</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function _changeName(firstName){\n    return {firstName};\n}\n\nfunction FnUI(){\n    const {invoke} = useConcent(&#x27;login&#x27;);\n    const changeName = e=&gt; invoke(_changeName, e.target.name);\n    &#x2F;&#x2F; ... return ui\n}\n\n@register(&#x27;login&#x27;)\nclass ClsUI extends React.Component{\n    changeName = e=&gt; this.ctx.invoke(_changeName, e.target.name)\n    render(){...}\n}\n</code></pre><ul>\n<li>sync</li>\n</ul>\n<p><strong><a href=\"https://codesandbox.io/s/green-tdd-g2mcr\">更多关于sync, 查看App2-1-sync.js文件</a></strong></p>\n<pre class=\"prettyprint language-jsx\"><code>function FnUI(){\n    const {sync, state} = useConcent(&#x27;login&#x27;);\n    return  &lt;input value={state.firstName} onChange={sync(&#x27;firstName&#x27;)} &#x2F;&gt;\n}\n\n@register(&#x27;login&#x27;)\nclass ClsUI extends React.Component{\n    changeName = e=&gt; this.ctx.invoke(_changeName, e.target.name)\n    render(){\n        return  &lt;input value={this.state.firstName} onChange={this.ctx.sync(&#x27;firstName&#x27;)} &#x2F;&gt;\n    }\n}\n</code></pre><p>还记得我们在round 2开始比较前对concent提到了这样一句话：<strong>能够不只是追溯数据修改完整链路，还包括触发数据修改的源头</strong>，它是何含义呢，因为每一个concent组件的<code>ctx</code>都拥有一个唯一id<code>ccUniqueKey</code>标识当前组件实例，它是按<code>{className}_{randomTag}_{seq}</code>自动生成的，即类名(不提供是就是组件类型<code>$$CClass</code>, <code>$$CCFrag</code>, <code>$$CCHook</code>)加随机标签加自增序号，如果想刻意追踪修改源头ui，则人工维护<code>tag</code>，<code>ccClassKey</code>既可，再配合上<a href=\"https://github.com/concentjs/concent-plugin-redux-devtool/actions/new\">concent-plugin-redux-devtool</a>就能完成我们的目标了。</p>\n<pre class=\"prettyprint language-js\"><code>function FnUI(){\n    const {sync, state, ccUniqueKey} = useConcent({module:&#x27;login&#x27;, tag:&#x27;xxx&#x27;}, &#x27;FnUI&#x27;);\n    &#x2F;&#x2F; tag 可加可不加，\n    &#x2F;&#x2F; 不加tag，ccUniqueKey形如: FnUI_xtst4x_1\n    &#x2F;&#x2F; 加了tag，ccUniqueKey形如: FnUI_xxx_1\n}\n\n@register({module:&#x27;login&#x27;, tag:&#x27;yyy&#x27;}, &#x27;ClsUI&#x27;)\nclass ClsUI extends React.Component{...}\n</code></pre><p>接入<code>concent-plugin-redux-devtool</code>后，可以看到任何动作修改Action里都会包含一个字段<code>ccUniqueKey</code>。\n<img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/6.png\" alt></p>\n<h3>回顾与总结</h3>\n<p>这一个回合我们针对数据修改方式做了全面对比，从而让开发者了解到从<code>concent</code>的角度来说，为了开发者的编码体验做出的各方面巨大努力。</p>\n<p>针对状态更新方式, 对比<code>redux</code>，当我们的所有动作流程压到最短，无action–&gt;reducer这样一条链路，无所谓的存函数还是副作用函数的区分(<code>rematch</code>、<code>dva</code>等提取的概念)，把这些概念交给<code>js</code>语法本身，会显得更加方便和清晰，你需要纯函数，就写<code>export function</code>，需要副作用函数就写<code>export async function</code>。</p>\n<p>对比<code>mobx</code>，一切都是可以任何拆开任意组合的基础函数，没有<code>this</code>，彻底得面向FP，给一个<code>input</code>预期<code>output</code>，这样的方式对测试容器也更加友好。</p>\n<table>\n<thead>\n<tr>\n<th>状态修改</th>\n<th>concent</th>\n<th>mbox</th>\n<th>redux</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基于不可变原则</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>最短链路</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>ui源头可追踪</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>无this</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>原子拆分&amp;合并提交</td>\n<td>Yes(基于lazy)</td>\n<td>Yes(基于transaction)</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n<h2>round 3 - 依赖收集</h2>\n<p>这个回合是非常重量级的一个环节，依赖收集让ui渲染可以保持最小范围更新，即精确更新，所以<code>vue</code>某些测试方面会胜出<code>react</code>，当我们为<code>react</code>插上依赖收集的翅膀后，看看会有什么更有趣的事情发生吧。</p>\n<p>再开始聊<code>依赖收集</code>之前，我们复盘一下<code>react</code>原本的渲染机制吧，当某一个组件发生状态改变时，如果它的自定义组件没有人工维护<code>shouldComponentUpdate</code>判断时，总是会从上往下全部渲染一遍，而<code>redux</code>的<code>cconnect</code>接口接管了<code>shouldComponentUpdate</code>行为，当一个action触发了动作修改时，所有connect过的组件都会将上一刻<code>mapStateToProps</code>得到的状态和当前最新<code>mapStateToProps</code>得到的状态做浅比较，从而决定是否要刷新包裹的子组件。</p>\n<p>到了hook时代，提供了<code>React.memo</code>来用户阻断这种&quot;株连式&quot;的更新，但是需要用户尽量传递<code>primitive</code>类型数据或者不变化的引用给<code>props</code>，否则<code>React.memo</code>的浅比较会返回false。</p>\n<p>但是<code>redux</code>存在的一个问题是，如果视图里某一刻已经不再使用某个状态了，它不该被渲染却被渲染了，<code>mobx</code>携带得基于运行时获取到ui对数据的最小订阅子集理念优雅的解决了这个问题，但是<code>concent</code>更近一步将依赖收集行为隐藏的更优雅，用户不需要不知道<code>observable</code>等相关术语和概念，某一次渲染你取值有了点这个值的依赖，而下一次渲染没有了对某个<code>stateKey</code>的取值行为就应该移出依赖，这一点<code>vue</code>做得很好，为了让<code>react</code>拥有更优雅、更全面的依赖收集机制，<code>concent</code>同样做出了很多努力。</p>\n<h3>redux版本(不支持)</h3>\n<p>解决依赖收集不是<code>redux</code>诞生的初衷，这里我们只能默默的将它请到候选区，参与下一轮的较量了。</p>\n<h3>mobx版本(computed,useObserver)</h3>\n<p>利用装饰器或者<code>decorate</code>函数标记要观察的属性或者计算的属性</p>\n<pre class=\"prettyprint language-js\"><code>import { observable, action, computed } from &quot;mobx&quot;;\n\nconst delay = (ms = 1000) =&gt; new Promise(r =&gt; setTimeout(r, ms));\n\nclass LoginStore {\n  @observable firstName = &quot;&quot;;\n\n  @observable lastName = &quot;&quot;;\n\n  @computed\n  get fullName(){\n    return &#96;${this.firstName}_${this.lastName}&#96;\n  }\n\n  @computed\n  get nickName(){\n    return &#96;${this.firstName}&gt;&gt;nicknick&#96;\n  }\n\n  @computed\n  get anotherNickName(){\n    return &#96;${this.nickName}_another&#96;\n  }\n}\n\nexport default new LoginStore();\n</code></pre><p>ui里使用了观察状态或者结算结果时，就产生了依赖</p>\n<ul>\n<li>仅对计算结果有依赖，类组件写法</li>\n</ul>\n<pre class=\"prettyprint language-jsx\"><code>@inject(&quot;store&quot;)\n@observer\nclass LoginCls extends Component {\n  state = {show:true};\n  toggle = ()=&gt; this.setState({show:!this.state.show})\n  render() {\n    const login = this.props.store.login;\n    return (\n      &lt;&gt;\n        &lt;h1&gt;Cls Small Comp&lt;&#x2F;h1&gt;\n        &lt;button onClick={this.toggle}&gt;toggle&lt;&#x2F;button&gt;\n        {this.state.show ? &lt;div&gt; fullName:{login.fullName}&lt;&#x2F;div&gt;: &quot;&quot;}\n      &lt;&#x2F;&gt;\n    )\n  }\n}\n</code></pre><ul>\n<li>仅对计算结果有依赖，函数组件写法</li>\n</ul>\n<pre class=\"prettyprint language-jsx\"><code>import { useObserver } from &quot;mobx-react&quot;;\n\n&#x2F;&#x2F; show为true时，当前组件读取了fullName，\n&#x2F;&#x2F; fullName由firstName和lastName计算而出\n&#x2F;&#x2F; 所以他的依赖是firstName、lastName\n&#x2F;&#x2F; 当show为false时，当前组件无任何依赖\nexport const LoginFnSmall = React.memo((props) =&gt; {\n  const [show, setShow] = React.useState(true);\n  const toggle = () =&gt; setShow(!show);\n  const { login } = store;\n\n  return useObserver(() =&gt; {\n    return (\n      &lt;&gt;\n        &lt;h1&gt;Fn Small Comp&lt;&#x2F;h1&gt;\n        &lt;button onClick={toggle}&gt;toggle&lt;&#x2F;button&gt;\n        {show ? &lt;div&gt; fullName:{login.fullName}&lt;&#x2F;div&gt;: &quot;&quot;}\n      &lt;&#x2F;&gt;\n    )\n  });\n});\n</code></pre><p>对状态有依赖和对计算结果有依赖无任何区别，都是在运行时从<code>this.props.login</code>上获取相关结果就产生了ui对数据的依赖关系。</p>\n<p><strong><a href=\"https://codesandbox.io/s/concent-login-ylbl4\">查看mobx示例</a></strong></p>\n<h3>concent(state,moduleComputed)</h3>\n<p>无需任何装饰器来标记观察属性和计算结果，仅仅是普通的<code>json</code>对象和函数，运行时阶段被自动转为<code>Proxy</code>对象。</p>\n<p>计算结果依赖</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; code in models&#x2F;login&#x2F;computed.js\n&#x2F;&#x2F; n: newState, o: oldState, f: fnCtx\n\n&#x2F;&#x2F; fullName的依赖是firstName lastName\nexport function fullName(n, o, f){\n  return &#96;${n.firstName}_${n.lastName}&#96;;\n}\n\n&#x2F;&#x2F; nickName的依赖是firstName\nexport function nickName(n, o, f){\n  return &#96;${n.firstName}&gt;&gt;nicknick&#96;\n}\n\n&#x2F;&#x2F; anotherNickName基于nickName缓存结果做二次计算，而nickName的依赖是firstName\n&#x2F;&#x2F; 所以anotherNickName的依赖是firstName，注意需将此函数放置到nickName下面\nexport function anotherNickName(n, o, f){\n  return &#96;${f.cuVal.nickName}_another&#96;;\n}\n</code></pre><ul>\n<li>仅对计算结果有依赖，类组件写法</li>\n</ul>\n<pre class=\"prettyprint language-jsx\"><code>@register({ module: &quot;login&quot; })\nclass _LoginClsSmall extends React.Component {\n  state = {show:true};\n  render() {\n    const { state, moduleComputed: mcu, syncBool } = this.ctx;\n\n    &#x2F;&#x2F; show为true时实例的依赖为firstName+lastName\n    &#x2F;&#x2F; 为false时，则无任何依赖\n    return (\n      &lt;&gt;\n        &lt;h1&gt;Fn Small Comp&lt;&#x2F;h1&gt;\n        &lt;button onClick={syncBool(&quot;show&quot;)}&gt;toggle&lt;&#x2F;button&gt;\n        {state.show ? &lt;div&gt; fullName:{mcu.fullName}&lt;&#x2F;div&gt; : &quot;&quot;}\n      &lt;&#x2F;&gt;\n    );\n  }\n}\n</code></pre><ul>\n<li>仅对计算结果有依赖，函数组件写法</li>\n</ul>\n<pre class=\"prettyprint language-jsx\"><code>export const LoginFnSmall = React.memo(props =&gt; {\n  const { state, moduleComputed: mcu, syncBool } = useConcent({\n    module: &quot;login&quot;,\n    state: { show: true }\n  });\n\n  return (\n    &lt;&gt;\n      &lt;h1&gt;Fn Small Comp&lt;&#x2F;h1&gt;\n      &lt;button onClick={syncBool(&quot;show&quot;)}&gt;toggle&lt;&#x2F;button&gt;\n      {state.show ? &lt;div&gt; fullName:{mcu.fullName}&lt;&#x2F;div&gt; : &quot;&quot;}\n    &lt;&#x2F;&gt;\n  );\n});\n</code></pre><p>和<code>mobx</code>一样，对状态有依赖和对计算结果有依赖无任何区别，在运行时从<code>ctx.state</code>上获取相关结果就产生了ui对数据的依赖关系，每一次渲染<code>concent</code>都在动态的收集当前实例最新的依赖，在实例<code>didUpdate</code>阶段移出已消失的依赖。</p>\n<ul>\n<li>生命周期依赖</li>\n</ul>\n<p><code>concent</code>的架构里是统一了类组件和函数组件的生命周期函数的，所以当某个状态被改变时，对此有依赖的生命周期函数会被触发，并支持类与函数共享此逻辑</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/7.png\" alt></p>\n<pre class=\"prettyprint language-js\"><code>export const setupSm = ctx=&gt;{\n  &#x2F;&#x2F; 当firstName改变时，组件渲染渲染完毕后会触发\n  ctx.effect(()=&gt;{\n    console.log(&#x27;fisrtName changed&#x27;, ctx.state.fisrtName);\n  }, [&#x27;firstName&#x27;])\n}\n\n&#x2F;&#x2F; 类组件里使用\nexport const LoginFnSmall = React.memo(props =&gt; {\n  console.log(&#x27;Fn Comp &#x27; + props.tag);\n  const { state, moduleComputed: mcu, sync } = useConcent({\n    module: &quot;login&quot;,setup: setupSm, state: { show: true }\n  });\n  &#x2F;&#x2F;...\n}\n\n&#x2F;&#x2F; 函数组件里使用\n@register({ module: &quot;login&quot;, setup:setupSm })\nclass _LoginClsSmall extends React.Component {...}\n</code></pre><p><strong><a href=\"https://codesandbox.io/s/concent-login-ylbl4\">查看concent示例</a></strong></p>\n<p><strong><a href=\"https://juejin.im/post/5deb43256fb9a0166316c3e9\">查看更多关于ctx.effect</a></strong></p>\n<h3>回顾与总结</h3>\n<p>在依赖收集这一个回合，<code>concent</code>的依赖收集形式、和组件表达形式，和<code>mobx</code>区别都非常大，整个依赖收集过程没有任何其他多余的api介入, 而<code>mbox</code>需用<code>computed</code>修饰getter字段，在函数组件需要使用<code>useObserver</code>包状态返回UI，<code>concent</code>更注重一切皆函数，在组织计算代码的过程中消除的<code>this</code>这个关键字，利用<code>fnCtx</code>函数上下文传递已计算结果，同时显式的区分<code>state</code>和<code>computed</code>的盛放容器对象。</p>\n<table>\n<thead>\n<tr>\n<th>依赖收集</th>\n<th>concent</th>\n<th>mbox</th>\n<th>redux</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>支持运行时收集依赖</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>精准渲染</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>无this</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>只需一个api介入</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n<h2>round 4 - 衍生数据</h2>\n<p>还记得<code>mobx</code>的口号吗？任何可以从应用程序状态派生的内容都应该派生，揭示了一个的的确确存在且我们无法逃避的问题，大多数应用状态传递给ui使用前都会伴随着一个计算过程，其计算结果我们称之为衍生数据。</p>\n<p>我们都知道在<code>vue</code>里已内置了这个概念，暴露了一个可选项<code>computed</code>用于处理计算过程并缓存衍生数据，<code>react</code>并无此概念，<code>redux</code>也并不提供此能力，但是<code>redux</code>开放的中间件机制让社区得以找到切入点支持此能力，所以此处我们针对<code>redux</code>说到的计算指的已成为事实上的流行标准库<code>reslect</code>.</p>\n<p><code>mobx</code>和<code>concent</code>都自带计算支持，我们在上面的<strong>依赖收集</strong>回合里已经演示了<code>mobx</code>和<code>concent</code>的衍生数据代码，所以此轮仅针对<code>redux</code>书写衍生数据示例</p>\n<h3>redux(reselect)</h3>\n<p>redux最新发布<code>v7</code>版本，暴露了两个api，<code>useDispatch</code>和<code>useSelector</code>，用法以之前的<code>mapStateToState</code>和<code>mapDispatchToProps</code>完全对等，我们的示例里会用类组件和函数组件都演示出来。</p>\n<p>定义selector</p>\n<pre class=\"prettyprint language-js\"><code>import { createSelector } from &quot;reselect&quot;;\n\n&#x2F;&#x2F; getter，仅用于取值，不参与计算\nconst getFirstName = state =&gt; state.login.firstName;\nconst getLastName = state =&gt; state.login.lastName;\n\n&#x2F;&#x2F; selector，等同于computed，手动传入计算依赖关系\nexport const selectFullName = createSelector(\n  [getFirstName, getLastName],\n  (firstName, lastName) =&gt; &#96;${firstName}_${lastName}&#96;\n);\n\nexport const selectNickName = createSelector(\n  [getFirstName],\n  (firstName) =&gt; &#96;${firstName}&gt;&gt;nicknick&#96;\n);\n\nexport const selectAnotherNickName = createSelector(\n  [selectNickName],\n  (nickname) =&gt; &#96;${nickname}_another&#96;\n);\n\n</code></pre><p>类组件获取selector</p>\n<pre class=\"prettyprint language-js\"><code>import React from &quot;react&quot;;\nimport { connect } from &quot;react-redux&quot;;\nimport * as loginAction from &quot;models&#x2F;login&#x2F;action&quot;;\nimport {\n  selectFullName,\n  selectNickName,\n  selectAnotherNickName\n} from &quot;models&#x2F;login&#x2F;selector&quot;;\n\n@connect(\n  state =&gt; ({\n    firstName: state.login.firstName,\n    lastName: state.login.lastName,\n    fullName: selectFullName(state),\n    nickName: selectNickName(state),\n    anotherNickName: selectAnotherNickName(state),\n  }), &#x2F;&#x2F; mapStateToProps\n  dispatch =&gt; ({\n    &#x2F;&#x2F; mapDispatchToProps\n    changeFirstName: e =&gt;\n      dispatch(loginAction.changeFirstName(e.target.value)),\n    asyncChangeFirstName: e =&gt;\n      dispatch(loginAction.asyncChangeFirstName(e.target.value)),\n    changeLastName: e =&gt; dispatch(loginAction.changeLastName(e.target.value))\n  })\n)\nclass Counter extends React.Component {\n  render() {\n    const {\n      firstName,\n      lastName,\n      fullName,\n      nickName,\n      anotherNickName,\n      changeFirstName,\n      asyncChangeFirstName,\n      changeLastName\n    } = this.props;\n    return &#x27;ui ...&#x27;\n  }\n}\n\nexport default Counter;\n</code></pre><p>函数组件获取selector</p>\n<pre class=\"prettyprint language-js\"><code>import * as React from &quot;react&quot;;\nimport { useSelector, useDispatch } from &quot;react-redux&quot;;\nimport * as loginAction from &quot;models&#x2F;login&#x2F;action&quot;;\nimport {\n  selectFullName,\n  selectNickName,\n  selectAnotherNickName\n} from &quot;models&#x2F;login&#x2F;selector&quot;;\n\nconst Counter = () =&gt; {\n  const { firstName, lastName } = useSelector(state =&gt; state.login);\n  const fullName = useSelector(selectFullName);\n  const nickName = useSelector(selectNickName);\n  const anotherNickName = useSelector(selectAnotherNickName);\n  const dispatch = useDispatch();\n  const changeFirstName = (e) =&gt; dispatch(loginAction.changeFirstName(e.target.value));\n  const asyncChangeFirstName = (e) =&gt; dispatch(loginAction.asyncChangeFirstName(e.target.value));\n  const changeLastName = (e) =&gt; dispatch(loginAction.changeLastName(e.target.value));\n\n  return &#x27;ui...&#x27;\n  );\n};\n\nexport default Counter;\n</code></pre><p><strong><a href=\"https://codesandbox.io/s/redux-login-6uqg8\">redux衍生数据在线示例</a></strong></p>\n<h3>mobx(computed装饰器)</h3>\n<p>见上面依赖收集的实例代码，此处不再重叙。</p>\n<h3>concent(moduleComputed直接获取)</h3>\n<p>见上面依赖收集的实例代码，此处不再重叙。</p>\n<h3>回顾与总结</h3>\n<p>相比<code>mobx</code>可以直接从<code>this.pops.someStore</code>获取，<code>concent</code>可以直接从<code>ctx.moduleComputed</code>上获取，多了一个手动维护计算依赖的过程或映射挑选结果的过程，相信哪种方式是开发者更愿意使用的这个结果已经一目了然了。</p>\n<table>\n<thead>\n<tr>\n<th>衍生数据</th>\n<th>concent</th>\n<th>mbox</th>\n<th>redux(reselect)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>自动维护计算结果之间的依赖</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>触发读取计算结果时收集依赖</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>计算函数无this</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n</tbody>\n</table>\n<h2>round 5 - 实战TodoMvc</h2>\n<p>上面4个回合结合了一个个鲜活的代码示例，综述了3个框架的特点与编码风格，相信读者期望能有更加接近生产环境的代码示例来看出其差异性吧，那么最后让我们以<code>TodoMvc</code>来收尾这次特性大比拼，期待你能够更多的了解并体验<code>concent</code>，开启 <strong>不可变</strong> &amp; <strong>依赖收集</strong> 的react编程之旅吧。</p>\n<h3>redux-todo-mvc</h3>\n<p><strong><a href=\"https://codesandbox.io/s/todo-mvc-redux-49kg0\">查看redux-todo-mvc演示</a></strong></p>\n<p>action 相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/8.png\" alt></p>\n<p>reducer 相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/9.png\" alt></p>\n<p>computed 相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/10.png\" alt></p>\n<h3>mobx-todo-mvc</h3>\n<p><strong><a href=\"https://codesandbox.io/s/todo-mvc-mbox-k42q1\">查看mobx-todo-mvc演示</a></strong></p>\n<p>action 相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/11.png\" alt></p>\n<p>computed 相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/12.png\" alt></p>\n<h3>concent-todo-mvc</h3>\n<p><strong><a href=\"https://codesandbox.io/s/todoapp-react-concent-fvgvc\">查看concent-todo-mvc演示</a></strong></p>\n<p>reducer相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/13.png\" alt></p>\n<p>computed相关</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/14.png\" alt></p>\n<h2>end</h2>\n<p>最后让我们用一个<a href=\"https://codesandbox.io/s/concent-watch-7j0mw\">最简版本的concent应用</a>结束此文，未来的你会选择concent作为你的react开发武器吗？</p>\n<pre class=\"prettyprint language-jsx\"><code>import React from &quot;react&quot;;\nimport &quot;.&#x2F;styles.css&quot;;\nimport { run, useConcent, defWatch } from &#x27;concent&#x27;;\n\nrun({\n  login:{\n    state:{\n      name:&#x27;c2&#x27;,\n      addr:&#x27;bj&#x27;,\n      info:{\n        sex: &#x27;1&#x27;,\n        grade: &#x27;19&#x27;,\n      }\n    },\n    reducer:{\n      selectSex(sex, moduleState){\n        const info = moduleState.info;\n        info.sex = sex;\n        return {info};\n      }\n    },\n    computed: {\n      funnyName(newState){\n        &#x2F;&#x2F; 收集到funnyName对应的依赖是 name\n        return &#96;${newState.name}_${Date.now()}&#96;\n      },\n      otherFunnyName(newState, oldState, fnCtx){\n        &#x2F;&#x2F; 获取了funnyName的计算结果和newState.addr作为输入再次计算\n        &#x2F;&#x2F; 所以这里收集到otherFunnyName对应的依赖是 name addr\n        return &#96;${fnCtx.cuVal.funnyName}_${newState.addr}&#96;\n      }\n    },\n    watch:{\n      &#x2F;&#x2F; watchKey name和stateKey同名，默认监听name变化\n      name(newState, oldState){\n        console.log(&#96;name changed from ${newState.name} to ${oldState.name}&#96;);\n      },\n      &#x2F;&#x2F; 从newState 读取了addr， info两个属性的值，当前watch函数的依赖是 addr, info\n      &#x2F;&#x2F; 它们任意一个发生变化时，都会触发此watch函数\n      addrOrInfoChanged: defWatch((newState, oldState, fnCtx)=&gt;{\n        const {addr, info} = newState;\n        if(fnCtx.isFirstCall)return;&#x2F;&#x2F; 仅为了收集到依赖，不执行逻辑\n        console.log(&#96;addr is${addr}, info is${JSON.stringify(info)}&#96;);\n      }, {immediate:true})\n    }\n  }\n})\n\nfunction UI(){\n  console.log(&#x27;UI with state value&#x27;);\n  const {state, sync, dispatch} = useConcent(&#x27;login&#x27;);\n  return (\n    &lt;div&gt;\n      name:&lt;input value={state.name} onChange={sync(&#x27;name&#x27;)} &#x2F;&gt;\n      addr:&lt;input value={state.addr} onChange={sync(&#x27;addr&#x27;)} &#x2F;&gt;\n      &lt;br &#x2F;&gt;\n      info.sex:&lt;input value={state.info.sex} onChange={sync(&#x27;info.sex&#x27;)} &#x2F;&gt;\n      info.grade:&lt;input value={state.info.grade} onChange={sync(&#x27;info.grade&#x27;)} &#x2F;&gt;\n      &lt;br &#x2F;&gt;\n      &lt;select value={state.info.sex} onChange={(e)=&gt;dispatch(&#x27;selectSex&#x27;, e.target.value)}&gt;\n        &lt;option value=&quot;male&quot;&gt;male&lt;&#x2F;option&gt;\n        &lt;option value=&quot;female&quot;&gt;female&lt;&#x2F;option&gt;\n      &lt;&#x2F;select&gt;\n    &lt;&#x2F;div&gt;\n  );\n}\n\nfunction UI2(){\n  console.log(&#x27;UI2 with comptued value&#x27;);\n  const {state, moduleComputed, syncBool} = useConcent({module:&#x27;login&#x27;, state:{show:true}});\n  return (\n    &lt;div&gt;\n      {&#x2F;* 当show为true的时候，当前组件的依赖是funnyName对应的依赖 name *&#x2F;}\n      {state.show? &lt;span&gt;dep is name: {moduleComputed.funnyName}&lt;&#x2F;span&gt; : &#x27;UI2 no deps now&#x27;}\n      &lt;br&#x2F;&gt;&lt;button onClick={syncBool(&#x27;show&#x27;)}&gt;toggle show&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n}\n\nfunction UI3(){\n  console.log(&#x27;UI3 with comptued value&#x27;);\n  const {state, moduleComputed, syncBool} = useConcent({module:&#x27;login&#x27;, state:{show:true}});\n  return (\n    &lt;div&gt;\n      {&#x2F;* 当show为true的时候，当前组件的依赖是funnyName对应的依赖 name addr *&#x2F;}\n      {state.show? &lt;span&gt;dep is name,addr: {moduleComputed.otherFunnyName}&lt;&#x2F;span&gt; : &#x27;UI3 no deps now&#x27;}\n      &lt;br&#x2F;&gt;&lt;button onClick={syncBool(&#x27;show&#x27;)}&gt;toggle show&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n}\n\nexport default function App() {\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;h3&gt;try click toggle btn and open console to see render log&lt;&#x2F;h3&gt;\n      &lt;UI &#x2F;&gt;\n      &lt;UI &#x2F;&gt;\n      &lt;UI2 &#x2F;&gt;\n      &lt;UI3 &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n}\n</code></pre><p><a href=\"https://github.com/concentjs/concent\">❤ star me if you like concent ^_^</a></p>\n<p><a href=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/15.png\">Edit on CodeSandbox</a>\n<img src=\"https://user-gold-cdn.xitu.io/2019/11/17/16e79b2dee1e3c4d?w=302&amp;h=62&amp;f=png&amp;s=9408\" alt=\"https://codesandbox.io/s/concent-guide-xvcej\"></p>\n<p><a href=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/16.png\">Edit on StackBlitz</a>\n<img src=\"https://user-gold-cdn.xitu.io/2019/11/17/16e79b30771f4fd4?w=302&amp;h=61&amp;f=png&amp;s=10028\" alt=\"https://stackblitz.com/edit/cc-multi-ways-to-wirte-code\"></p>\n<p>如果有关于concent的疑问，可以扫码加群咨询，会尽力答疑解惑，帮助你了解更多。</p>\n<p><img src=\"https://raw.githubusercontent.com/fantasticsoul/assets/master/article-img/rmc-comparison/17.png\" alt></p>\n</div>",
            "title": "redux、mobx、concent特性大比拼, 看后生如何对局前辈",
            "last_reply_at": "2020-04-09T07:56:37.246Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 754,
            "create_at": "2020-04-08T02:44:32.184Z",
            "author": {
                "loginname": "fantasticsoul",
                "avatar_url": "https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"
            }
        },
        {
            "id": "5e8ea81158ab6717beb7ec9c",
            "author_id": "5875bd3d06fa6e2a4e4f730b",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>起因是在写一个前置监控服务项目，需要数据相对实时的传输，然后正好看到nodejs文档中，实现websocket看起来挺简单的(其实只是冰山一角还有坑)，所以就打算自己实现一遍websocket通讯服务。先看看nodejs官方文档怎么实现的：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; nodejs在http模块实现websocket的例子\nconst http = require(&#x27;http&#x27;);\n\n&#x2F;&#x2F; Create an HTTP server\nconst server = http.createServer((req, res) =&gt; {\n  res.writeHead(200, { &#x27;Content-Type&#x27;: &#x27;text&#x2F;plain&#x27; });\n  res.end(&#x27;okay&#x27;);\n});\nserver.on(&#x27;upgrade&#x27;, (req, socket, head) =&gt; {\n  socket.write(&#x27;HTTP&#x2F;1.1 101 Web Socket Protocol Handshake\\r\\n&#x27; +\n               &#x27;Upgrade: WebSocket\\r\\n&#x27; +\n               &#x27;Connection: Upgrade\\r\\n&#x27; +\n               &#x27;\\r\\n&#x27;);\n\n  socket.pipe(socket); &#x2F;&#x2F; echo back\n});\n</code></pre><p>第一眼以为通过upgrade拿到socket套接字，然后就可以直接用socket.write和socket.on(‘data’)的方法来发送和获取数据。但事实并不是这样。</p>\n<h1>第一坑：Sec-WebSocket-Accept</h1>\n<p>我在浏览器中写好websocket的例子：</p>\n<pre class=\"prettyprint language-js\"><code>    var ws = new WebSocket(&#96;ws:&#x2F;&#x2F;${window.location.host}&#x2F;&#96;);\n    ws.onopen = function()\n    {\n        console.log(&quot;握手成功&quot;);\n        ws.send(&quot;发送数据测试&quot;);\n    };      \n    ws.onmessage = function (e) \n    { \n        console.log(e.data);\n    };\n</code></pre><p>结果一连接就断开，说我没有Sec-WebSocket-Accept这个http头，网上一查一点结果都没有，看来实现这个的确实不多。\n找来找去终于找到了websocket的协议文档(<a href=\"https://tools.ietf.org/html/rfc6455\">https://tools.ietf.org/html/rfc6455</a>)。</p>\n<p>发现Sec-WebSocket-Accept这个返回头是根据客户端的请求头sec-websocket-key,加上全局唯一ID(258EAFA5-E914-47DA-95CA-C5AB0DC85B11)后使用sha1摘要后，再以base64格式输出。</p>\n<pre class=\"prettyprint language-js\"><code>const crypto=require(&#x27;crypto&#x27;)\nfunction getSecWebSocketAccept (secWebsocketKey){\n    return crypto.createHash(&#x27;sha1&#x27;)\n    .update(&#96;${secWebsocketKey}258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#96;)\n    .digest(&#x27;base64&#x27;);\n}\n\nconst secWebSocketAccept = getSecWebSocketAccept(req.headers[&#x27;sec-websocket-key&#x27;])\nsocket.write(&#x27;HTTP&#x2F;1.1 101 Web Socket Protocol Handshake\\r\\n&#x27; +\n            &#x27;Upgrade: WebSocket\\r\\n&#x27; +\n            &#x27;Connection: Upgrade\\r\\n&#x27; +\n            &#x27;Sec-WebSocket-Accept: &#x27;+ secWebSocketAccept +&#x27;\\r\\n&#x27; +\n            &#x27;\\r\\n&#x27;);\n</code></pre><p>再刷新下浏览器，发现握手成功了。</p>\n<h1>第二坑:接收到的客户端数据是乱码</h1>\n<p>握手成功后，肯定是要看客户端给我发了什么数据，原来是个buffer，但toString后居然是乱码。</p>\n<pre class=\"prettyprint language-js\"><code>socket.on(&#x27;data&#x27;, (data) =&gt; {\n    console.log(data.toString())\n});\n</code></pre><p>当时就在想里面是不是有猫腻，一看果然websocket还有frame的概念，接收到data就是一个frame，在这个框架里面有一定的结构。</p>\n<p>在文档中叫Base Framing Protocol(<a href=\"https://tools.ietf.org/html/rfc6455#section-5.2\">https://tools.ietf.org/html/rfc6455#section-5.2</a>),大概的结构如下：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;**\n    我在第二三行重新加了个按字节和比特来计算的比例尺\n     0                   1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                   1               2               3               4\n     0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7\n    +-+-+-+-+-------+-+-------------+-------------------------------+\n    |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n    |I|S|S|S|  (4)  |A|     (7)     |             (16&#x2F;64)           |\n    |N|V|V|V|       |S|             |   (if payload len==126&#x2F;127)   |\n    | |1|2|3|       |K|             |                               |\n    +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n    |     Extended payload length continued, if payload len == 127  |\n    + - - - - - - - - - - - - - - - +-------------------------------+\n    |                               |Masking-key, if MASK set to 1  |\n    +-------------------------------+-------------------------------+\n    | Masking-key (continued)       |          Payload Data         |\n    +-------------------------------- - - - - - - - - - - - - - - - +\n    :                     Payload Data continued ...                :\n    + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n    |                     Payload Data continued ...                |\n    +---------------------------------------------------------------+\n    *&#x2F;\n</code></pre><p>什么意思呢？那么按照我标记的字节来算吧</p>\n<pre class=\"prettyprint\"><code>---\n第1个字节的第1个比特是FIN的值，用来标识这个frame信息传递是否结束，1是结束\n第1个字节的第2-3个比特是RSV的值，用来标识这个frame信息传递是否结束\n第1个字节的第4-8个比特是opcode的值，来标记状态1是文本数据2是二进制数据8是请求关闭链接\n---\n第2个字节的第1个比特是Mask的值，用来标识数据是否使用Masking-key来做异或解码\n第2个字节的第2-8个比特PayloadLen,\n代表数据长度，如果为126，则使用16位的扩展数据长\n代表数据长度，如果为127，则使用8位的扩展数据长度\n扩展长度使用大字端读取就好\n</code></pre><p>那知道这些就可以通过代码来实现解码,代码实现如下</p>\n<pre class=\"prettyprint language-js\"><code>function decodeSocketFrame (bufData){\n    let bufIndex = 0\n    const byte1 = bufData.readUInt8(bufIndex++).toString(2)\n    const byte2 = bufData.readUInt8(bufIndex++).toString(2)\n    const frame =  {\n        fin:parseInt(byte1.substring(0,1),2),\n        &#x2F;&#x2F; RSV是保留字段，暂时不计算\n        opcode:parseInt(byte1.substring(4,8),2),\n        mask:parseInt(byte2.substring(0,1),2),\n        payloadLen:parseInt(byte2.substring(1,8),2),\n    }\n    &#x2F;&#x2F; 如果frame.payloadLen为126或127说明这个长度不够了，要使用扩展长度了\n    &#x2F;&#x2F; 如果frame.payloadLen为126，则使用Extended payload length同时为16&#x2F;8字节数\n    &#x2F;&#x2F; 如果frame.payloadLen为127，则使用Extended payload length同时为64&#x2F;8字节数\n    &#x2F;&#x2F; 注意payloadLen得长度单位是字节(bytes)而不是比特(bit)\n    if(frame.payloadLen==126) {\n        frame.payloadLen = bufData.readUIntBE(bufIndex,2);\n        bufIndex+=2;\n    } else if(frame.payloadLen==127) {\n        &#x2F;&#x2F; 虽然是8字节，但是前四字节目前留空，因为int型是4字节不留空int会溢出\n        bufIndex+=4;\n        frame.payloadLen = bufData.readUIntBE(bufIndex,4);\n        bufIndex+=4;\n    }\n    if(frame.mask){\n        const payloadBufList = []\n        &#x2F;&#x2F; maskingKey为4字节数据\n        frame.maskingKey=[bufData[bufIndex++],bufData[bufIndex++],bufData[bufIndex++],bufData[bufIndex++]];\n        for(let i=0;i&lt;frame.payloadLen;i++) {\n            payloadBufList.push(bufData[bufIndex+i]^frame.maskingKey[i%4]);\n        }\n        frame.payloadBuf = Buffer.from(payloadBufList)\n    } else {\n        frame.payloadBuf = bufData.slice(bufIndex,bufIndex+frame.payloadLen)\n    }\n    return frame\n}\n</code></pre><p>那如果你解码数据，那么发送的时候其实也是要遵循这种基本框架的，所以还要进行加码成frame框架后再发送，同理根据协议，可以实现如下代码：</p>\n<pre class=\"prettyprint language-js\"><code>function encodeSocketFrame (frame){\n    const frameBufList = [];\n    &#x2F;&#x2F; 对fin位移七位则为10000000加opcode为10000001\n    const header = (frame.fin&lt;&lt;7)+frame.opcode;\n    console.log(header)\n    frameBufList.push(header)\n    const bufBits = Buffer.byteLength(frame.payloadBuf);\n    let payloadLen = bufBits;\n    let extBuf;\n    if(bufBits&gt;=126) {\n        &#x2F;&#x2F;65536是2**16即两字节数字极限\n        if(bufBits&gt;=65536) {\n            extBuf = Buffer.allocUnsafe(8);\n            buf.writeUInt32BE(bufBits, 4);\n            payloadLen = 127;\n        } else {\n            extBuf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(bufBits, 0);\n            payloadLen = 126;\n        }\n    }\n    let payloadLenBinStr = payloadLen.toString(2);\n    while(payloadLenBinStr.length&lt;8){payloadLenBinStr=&#x27;0&#x27;+payloadLenBinStr;}\n    frameBufList.push(parseInt(payloadLenBinStr,2));\n    if(bufBits&gt;=126) {\n        frameBufList.push(extBuf);\n    }\n    frameBufList.push(...frame.payloadBuf)\n    return Buffer.from(frameBufList)\n}\n</code></pre><p>那么我们发送和接受就简单了，直接通过socket再发送就好了，如下</p>\n<pre class=\"prettyprint language-js\"><code>socket.on(&#x27;data&#x27;, (data) =&gt; {\n    console.log(decodeSocketFrame(data).payloadBuf.toString())\n    socket.write(encodeSocketFrame({\n        fin:1,\n        opcode:1,\n        payloadBuf:Buffer.from(&#x27;你好&#x27;)\n    }))\n});\n</code></pre><h1>总结</h1>\n<p>其实websocket和http对于socket来说都是在上面加了一层协议，通过不同方法来实现其功能，随着技术的发展，协议也确实往复杂的方向发展。\n在工作种如果自己实现协议可能就太费时间了，但是如果是非工作，实现一遍也还是能收获良多的。</p>\n</div>",
            "title": "使用nodejs实现服务端websocket通讯",
            "last_reply_at": "2020-04-09T04:44:01.384Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 144,
            "create_at": "2020-04-09T04:44:01.384Z",
            "author": {
                "loginname": "zy445566",
                "avatar_url": "https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"
            }
        },
        {
            "id": "5e8e9c3064259617c49a5025",
            "author_id": "5c81f15090c14711cc8cb87e",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>教程讲了Nodejs的基础以及一些新特性、以及如何用nodejs封装一个类似于Express框架、还讲了Mongodb高级查询 聚合管道等内容</p>\n<p><strong>网盘链接</strong>： <a href=\"https://pan.baidu.com/s/1KmOwI3tKtMGwLXJhr5Om0w\">https://pan.baidu.com/s/1KmOwI3tKtMGwLXJhr5Om0w</a>      <strong>提取码</strong>：h87t</p>\n<p><strong>B站在线地址：</strong>  <a href=\"https://www.bilibili.com/video/av38925557/?p=1\">https://www.bilibili.com/video/av38925557/?p=1</a></p>\n<p>拿走不谢  新手帮助还是挺大的</p>\n</div>",
            "title": "2020录制的Nodejs+Mongodb+Koa2入门实战视频教程（44讲网盘免费下载-B站免费看）",
            "last_reply_at": "2020-04-09T03:53:20.003Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 186,
            "create_at": "2020-04-09T03:53:20.003Z",
            "author": {
                "loginname": "phonegap100",
                "avatar_url": "https://avatars1.githubusercontent.com/u/5773766?v=4&s=120"
            }
        },
        {
            "id": "5e8d905964259617c49a4e24",
            "author_id": "5cab188c7edd13064e05363f",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>最近开发公司项目，前台react，后台nestjs，，有个接口典型的三层数据结构，ts类型定义完全一样，，</p>\n<p>是不是类型定义文件完全可以放在公共文件里，前后台一个项目中？</p>\n<p>…bs 架构最佳实践？</p>\n<p>本人项目一般都前后台管理端都放一个项目里，目前好像没啥大问题…毕竟前台管理端都是打包到文件，重启也没影响。</p>\n<p>2020新方案？</p>\n</div>",
            "title": "新尝试：基于typescript的前后端共用类型？ web开发最佳组合？",
            "last_reply_at": "2020-04-09T01:53:18.968Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 403,
            "create_at": "2020-04-08T08:50:33.011Z",
            "author": {
                "loginname": "ganshiqingyuan",
                "avatar_url": "https://avatars0.githubusercontent.com/u/33950951?v=4&s=120"
            }
        },
        {
            "id": "5e8b552f64259617c49a49c6",
            "author_id": "55a668125a4b4a86539c2fd4",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FrY4tanvKjDG9cTp2TCs30U0_5J1\" alt=\"1.png\"></p>\n<p>目前还在编写文档和完善测试用例的阶段，忍不住想要分享一下。</p>\n</div>",
            "title": "如果有这样的 Vue SSR插件，你会想要吗？",
            "last_reply_at": "2020-04-09T01:42:49.285Z",
            "good": false,
            "top": false,
            "reply_count": 10,
            "visit_count": 746,
            "create_at": "2020-04-06T16:13:35.887Z",
            "author": {
                "loginname": "1340641314",
                "avatar_url": "https://avatars0.githubusercontent.com/u/8424643?v=4&s=120"
            }
        },
        {
            "id": "5e8836a758ab6717beb7e220",
            "author_id": "553ca9667533b0bb7ebd9dee",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FtnJD33Eb6rLs8-fws8FpByIEhE5\" alt=\"image.png\">\n怎么进程这么多？求知道的同学 解释一波</p>\n</div>",
            "title": "eggjs 进程数默认这么多正常吗？",
            "last_reply_at": "2020-04-09T01:31:35.237Z",
            "good": false,
            "top": false,
            "reply_count": 5,
            "visit_count": 682,
            "create_at": "2020-04-04T07:26:31.835Z",
            "author": {
                "loginname": "shenjianzch",
                "avatar_url": "https://avatars0.githubusercontent.com/u/7286498?v=4&s=120"
            }
        },
        {
            "id": "5e8b55ce58ab6717beb7e5f4",
            "author_id": "5b50a37aaef62f1b0f9e048a",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>假如我有一个document的集合，也有一个用户的集合，用户的集合中包含love字段（数组），里面的内容包含我收藏的文档id，那么请问如果文档过多，是否会造成文档的16M限制，应该如何处理这样的问题？如何设计表？</p>\n</div>",
            "title": "node+mongodb+mongoose收藏功能的文档限制",
            "last_reply_at": "2020-04-08T19:00:49.119Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 702,
            "create_at": "2020-04-06T16:16:14.133Z",
            "author": {
                "loginname": "xu1260114313",
                "avatar_url": "https://avatars2.githubusercontent.com/u/21236047?v=4&s=120"
            }
        },
        {
            "id": "5e8c309658ab6717beb7e78d",
            "author_id": "5e13183c4bea432607fcd1d9",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><pre class=\"prettyprint language-js\"><code>  const success = 1, fail = 0 ,pendding = -1;\n   function MyPromise(deal){\n\t  this.status = null\n\t  this.freeze = null\n\t  Object.defineProperty(this,&#x27;status&#x27;,{\n\t\t  get:function(){\n\t\t\t  &#x2F;&#x2F; console.log(&quot;get&quot;)\n\t\t\t  return status;\n\t\t  },\n\t\t  set:function(newValue){\n\t\t\t  &#x2F;&#x2F; console.log(&quot;set&quot;)\n\t\t\t  status = newValue; &#x2F;&#x2F;通过订阅模式    获取异步执行完成的时机\n\t\t\t  this.then(this.resolveCallback,this.rejectallback)\n\t\t  \n\t\t  },\n\t\t  enumerable : true,\n\t\t  configurable : true\n\t  })\n\t  console.log(this)\n\t  this.status = pendding;\n\t  deal(this.resolve.bind(this),this.reject.bind(this))\n\t  &#x2F;&#x2F;使用bind是因为函数作为参数传入函数中 调用者为deal函数  resolve和reject中的 this指向变为window或undefined或者箭头函数获取的this\n\t  return this\n  \n   }\n   MyPromise.prototype.resolve = function(res) {\n   \t  if(this.freeze) return\n\t  console.log(res)\n\t  console.log(this)\n\t  this.value = res  &#x2F;&#x2F;value的赋值必须在状态变更之前   不然执行get函数执行then方法时无法获取value\n\t  this.freeze = true\n\t  this.status = success\n\t  \n   };\n\tMyPromise.prototype.reject = function(err) {\n\t  if(this.freeze) return\n\t  console.log(err)\n\t  this.value = err\n\t  this.freeze = true\n\t  this.status = fail\n\t\t\t  \n   };\n\tMyPromise.prototype.then = function(resolveCallback,rejectallback) {\n\t  &#x2F;&#x2F;将回调函数储存在this上\n\t   this.resolveCallback = resolveCallback\n\t   this.rejectallback = rejectallback\n\t   if(this.status == -1) return this\n\t\t  &#x2F;&#x2F; console.log(this.status+&quot;5656459&quot;)\n\t\t  &#x2F;&#x2F; console.log(typeof this.resolveCallback)\n\t\t  &#x2F;&#x2F;此处status为字符串类型 所以不能使用===  为什么是字符串类型暂时未知\n\t\t  this.status == 1 &amp;&amp; this.resolveCallback &amp;&amp; this.resolveCallback(this.value)\n\t\t  this.status == 0 &amp;&amp; this.rejectallback  &amp;&amp; this.rejectallback(this.value)\n  \n\t  &#x2F;&#x2F; setTimeout(()=&gt;{\n\t  &#x2F;&#x2F; \tconsole.log(this.status+&quot;5656459&quot;)\n\t  &#x2F;&#x2F; \t&#x2F;&#x2F; console.log(typeof this.resolveCallback)\n  \n\t  &#x2F;&#x2F; \tthis.status == 1 &amp;&amp; this.resolveCallback(this.value)\n\t  &#x2F;&#x2F; \tthis.status == 0 &amp;&amp; rejectallback(this.value)\n\t  &#x2F;&#x2F; },0) \n\t  return this\n   };\n   let a =  new MyPromise((resolve)=&gt;{\n\t  setTimeout(()=&gt;{ &#x2F;&#x2F;模拟异步操作\n\t\t  console.log(&quot;454&quot;)\n\t\t  resolve(78980)\n\t\t  resolve(5656)\n\t  },1000)\n\t  &#x2F;&#x2F; new Promise((resolve1)=&gt;{resolve1()}).then(()=&gt;{resolve(456464)})\n   })\n   &#x2F;&#x2F; .then(res=&gt;{console.log(res+&quot;45656&quot;)})\n  &#x2F;&#x2F;console.log(a.then(res=&gt;{console.log(res+&quot;45656&quot;)}).then(res=&gt;{console.log(res+&quot;8888&quot;)}))\n   &#x2F;&#x2F; 如果连续.then后面的方法会覆盖之前的方法  储存回调函数应该使用数组然后做相应的处理\n\tconsole.log(a.then(res=&gt;{console.log(res+&quot;45656&quot;)}))\n</code></pre></div>",
            "title": "订阅模式实现简单promise",
            "last_reply_at": "2020-04-08T04:00:11.200Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 585,
            "create_at": "2020-04-07T07:49:42.319Z",
            "author": {
                "loginname": "zhsonga",
                "avatar_url": "https://avatars1.githubusercontent.com/u/18735806?v=4&s=120"
            }
        },
        {
            "id": "5e83f7e758ab6717beb7d9f8",
            "author_id": "5e83f77958ab6717beb7d9f5",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>请问各位前辈，Node.js生成api文档有哪些推荐的工具及方法？</p>\n</div>",
            "title": "node.js生成API文档",
            "last_reply_at": "2020-04-08T03:36:30.407Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 1340,
            "create_at": "2020-04-01T02:09:43.393Z",
            "author": {
                "loginname": "EvansX",
                "avatar_url": "https://avatars3.githubusercontent.com/u/35906821?v=4&s=120"
            }
        },
        {
            "id": "5e8d2cee58ab6717beb7e947",
            "author_id": "5e81836f58ab6717beb7d52e",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>视频教程：</p>\n<ul>\n<li>cool-admin后端简单入门视频(快速写6个api接口)：<a href=\"https://www.bilibili.com/video/BV1SE411j74K\">https://www.bilibili.com/video/BV1SE411j74K</a></li>\n<li>cool-admin前后端配合使用：<a href=\"https://www.bilibili.com/video/av90478011/\">https://www.bilibili.com/video/av90478011/</a></li>\n<li>cool-admin前端crud内部培训教程：<a href=\"https://www.bilibili.com/video/av89512654/\">https://www.bilibili.com/video/av89512654/</a></li>\n</ul>\n<p>文档：</p>\n<ul>\n<li>cool-admin:   <a href=\"https://docs.cool-admin.com\">https://docs.cool-admin.com</a></li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FrS3FPZkqlVEeNqpvMZngyKUWvVS\" alt=\"数据权限.png\">\n<img src=\"//static.cnodejs.org/Fp8gmK7P1u-02CyeKyvZwaWOz6wp\" alt=\"部门管理.png\">\n<img src=\"//static.cnodejs.org/Fgjdh9_GpyuNq39_alleBTdFYnmc\" alt=\"3.png\">\n<img src=\"//static.cnodejs.org/Fn74IbmYU69YDiDAKd4utYn_DHbK\" alt=\"4.png\">\n<img src=\"//static.cnodejs.org/FoEx6K5AQm7qF8UuTV4nJ_Xye-IL\" alt=\"6.png\"></p>\n</div>",
            "title": "egg.js 快速编写后台管理系统",
            "last_reply_at": "2020-04-08T02:16:33.646Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 386,
            "create_at": "2020-04-08T01:46:22.032Z",
            "author": {
                "loginname": "cool-team-official",
                "avatar_url": "https://avatars2.githubusercontent.com/u/62868950?v=4&s=120"
            }
        },
        {
            "id": "5e8aaac158ab6717beb7e4a8",
            "author_id": "5b4fdf5faef62f1b0f9e0434",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>\t&#x2F;&#x2F;服务端处理请求的代码: \n\t const fs = require(&#x27;fs&#x27;);\n\t const readline = require(&#x27;readline&#x27;);\n\t async getLog(req, res) {\n\t  const _this = this;\n\t  try {\n\t\tconst { createReadStream } = fs;\n\t\tconst log = &#x27;&#x2F;opt&#x2F;example.log&#x27;; &#x2F;&#x2F; log 大小：40MB\n\t\tconst readStream = createReadStream(log);\n\t\tconst rl = readline.createInterface(readStream, res);\n\t\trl.on(&quot;close&quot;, () =&gt; {\n\t\t  console.log(&quot;end&quot;);\n\t\t  readStream.close();\n\t\t  res.end();\n\t\t});\n\t  } catch (e) {\n\t\tlogger.error(&quot;获取log失败&quot;, e);\n\t\tres.json(_this.fail(ERROR_PARAMETER, &quot;获取日志失败，请稍后重试&quot;));\n\t  }\n\t}\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F;浏览器fetch代码：\nfetch(getLog)\n    .then(async response =&gt; {\n      const reader = response.body.getReader();\n      do {\n        let { done, value } = await reader.read();\n        console.log(value);  &#x2F;&#x2F;这里获取的只有一个undefined\n        if (done) {\n          break;\n        }\n      } while (true);\n    })\n    .catch(e =&gt; {\n      console.error(e);\n    });</code></pre></div>",
            "title": "express readline 返回逐行文件数据，fetch如何接收，求助大佬们",
            "last_reply_at": "2020-04-07T15:36:24.101Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 608,
            "create_at": "2020-04-06T04:06:25.917Z",
            "author": {
                "loginname": "assmdx",
                "avatar_url": "https://avatars2.githubusercontent.com/u/19722693?v=4&s=120"
            }
        },
        {
            "id": "5e89fd9664259617c49a484b",
            "author_id": "5add40b0464b1bfa6b425869",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>const Koa = require(&#x27;koa&#x27;);\nconst Router = require(&#x27;koa-router&#x27;);\nlet app = new Koa;\nlet router = new Router();\nconst auth = async (ctx, next) =&gt; {\n  &#x2F;&#x2F;  let error =  new Error(&#x27;this is an error&#x27;)\n  ctx.throw(500)\n    await next(error)\n}\nrouter.get(&#x27;&#x2F;:user&#x27;, auth, (ctx) =&gt; {\n    let user = ctx.params.user;\n    let name = ctx.params.name;\n    console.log(error)\n    ctx.response.type = &#x27;json&#x27;;\n    ctx.body = {\n        user,\n        name\n    }\n})\n app.use(async ( ctx, next) =&gt; {\n    try {\n        await next()\n    } catch (err) {\n        \n        ctx.type = &#x27;json&#x27;\n        ctx.body = {\n            message : err.message\n        } \n        ctx.app.emit(&#x27;error&#x27;, err, ctx);\n    }\n})\napp.use(router.routes())\napp.on(&#x27;error&#x27;, (err,ctx) =&gt; {\n    console.log(111)\n    ctx.type = &#x27;json&#x27;\n    ctx.body = {\n       message : err.message\n    }\n})\n\napp.listen(8092, () =&gt; {\n    console.log(&#x27;8092 is listening koa&#x27;);\n})\n</code></pre><p>当我没有加中间件异常处理函数的时候， koa 的on error 事件能触发，但是ctx.type  json 不能生效，不知道是什么原因，加上异常处理中间件后，on error 事件中的ctx.type 能生效，有木有大手子能解释一下</p>\n</div>",
            "title": "关于koa 异常处理这块",
            "last_reply_at": "2020-04-07T15:28:48.564Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 752,
            "create_at": "2020-04-05T15:47:34.133Z",
            "author": {
                "loginname": "chenye2017",
                "avatar_url": "https://avatars3.githubusercontent.com/u/26157597?v=4&s=120"
            }
        },
        {
            "id": "5e86cfbc64259617c49a43c2",
            "author_id": "59a50205bc6d953708128944",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><ol>\n<li>杭州A公司，boss上自己面找的，政企服务的，远程笔试没过，认栽，教育同学，多刷题。再次感谢内推的朋友</li>\n<li>上海B公司，boss上面对方找的，不清楚具体做哪块的，上来先两个Promise开胃，卒，教育同学，多刷题，不然后面都没机会聊。再次感谢内推的朋友</li>\n<li>上海Find,    boss上面找的，技术太忙为理由发了个在线编程题，简单搞定，后来回复说得分为0，行，可能没按照hackerrank上面的规范来吧，大哥这是国内，hackerrank是求职国外用的多一点好吧，逼格太高告辞打搅了。就怕说英文要求高，一入职全中文。</li>\n<li>上海达观，  boss上面找的，一个滑动窗口的题目，还有一个排序的题轻松拿下，人事反馈全错，打搅了告辞。</li>\n<li>上海PPIO，不太记得题目了，属于抖机灵的题目，还有处理日志脚本，不清楚可能我是一个假的node开发</li>\n<li>上海知言，没啥技术含量，看了下看准网评论，拖欠薪资，终面CEO挂了，很自信的一位大叔，聊天像是审问，就差素质三连了，和我不太对味。</li>\n<li>上海掌门一对一，对方要求熟悉c++插件以及eletron，挂了正常</li>\n<li>杭州宇链科技有限公司，面试很水，聊不下去。</li>\n<li>上海搜书神器，面试没劲，都要睡着了。</li>\n<li>上海普华永道，对英文有点要求，终面估计待遇问题挂了，结果还没出来，虽然我排斥996，但是也要恰饭的啊。</li>\n<li>上海XX公司，技术和CEO都对味，最关键疫情不受影响。</li>\n</ol>\n<p>上个图片分享一波\n<img src=\"https://tva1.sinaimg.cn/large/00831rSTgy1gdgjbk4vmsj30oh0jmgx6.jpg\" alt=\"281585891598_.pic_hd\"></p>\n</div>",
            "title": "分享一波近期找工作的经历，尽量按着时间顺序来。",
            "last_reply_at": "2020-04-07T10:22:46.904Z",
            "good": false,
            "top": false,
            "reply_count": 14,
            "visit_count": 1250,
            "create_at": "2020-04-03T05:55:08.340Z",
            "author": {
                "loginname": "jxycbjhc",
                "avatar_url": "https://avatars0.githubusercontent.com/u/16661897?v=4&s=120"
            }
        },
        {
            "id": "5e8c227564259617c49a4b35",
            "author_id": "5e8c21bc58ab6717beb7e760",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>我下了个nodejs项目文件夹,里面有<img src=\"//static.cnodejs.org/FjRFbO5EUuW1XlsFQ_xqZChPW-Fe\" alt=\"2.png\"> hsd文件夹中的是<img src=\"//static.cnodejs.org/FoUmpYSSQDIqN9W9XdcrfaIqqAZ5\" alt=\"3.png\"></p>\n<p>请问怎么运行呢？</p>\n</div>",
            "title": "菜鸟新学nodejs，下了个项目想请问下如何执行呢？",
            "last_reply_at": "2020-04-07T06:50:43.037Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 337,
            "create_at": "2020-04-07T06:49:25.286Z",
            "author": {
                "loginname": "zxhxh0128",
                "avatar_url": "https://avatars1.githubusercontent.com/u/32510477?v=4&s=120"
            }
        },
        {
            "id": "5e8a800458ab6717beb7e46d",
            "author_id": "577bc10ffb1d649f05fec7ad",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>从这里访问 ======&gt;  <a href=\"https://saso.js.org/\">https://saso.js.org/</a></p>\n<p>因为每次开发项目都花费大量时间配置 webpack，于是有了这个工具，现在在我的工作和生活中已经离不开这样一个打包工具了，求大佬们的建议</p>\n<p><img src=\"//static.cnodejs.org/FjkhkdwdrpnSrOEf2Z6hTF1i-dSb\" alt=\"image.png\"></p>\n</div>",
            "title": "分享一下历时一年的基于 webpack 的打包工具",
            "last_reply_at": "2020-04-07T05:00:14.313Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 734,
            "create_at": "2020-04-06T01:04:04.121Z",
            "author": {
                "loginname": "huruji",
                "avatar_url": "https://avatars2.githubusercontent.com/u/15937065?v=4&s=120"
            }
        },
        {
            "id": "5db261bdece3813ad9ba424b",
            "author_id": "5dab3db2ece3813ad9ba2eca",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>用户通过第三方应用（如Github）登录时，如果为新用户，那么跳转到确认用户信息页面，第三方应用返回的用户信息是不是应该用redis做缓存才行？要不确认用户信息页面怎么能知道第三方返回的用户信息呢？\n谢谢！</p>\n</div>",
            "title": "【新手】用户注册时分两个步骤，请问临时数据是不是要用redis来保存？",
            "last_reply_at": "2020-04-07T04:02:30.716Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 2981,
            "create_at": "2019-10-25T02:45:17.044Z",
            "author": {
                "loginname": "sytana",
                "avatar_url": "https://avatars2.githubusercontent.com/u/11701135?v=4&s=120"
            }
        },
        {
            "id": "5e81469e58ab6717beb7d3ee",
            "author_id": "5c0f5bc5f3d48d2397c10003",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>setTimeout(()=&gt;{\nconsole.log(‘timer1’)\nPromise.resolve().then(function() {\nconsole.log(‘promise1’)\n})\n}, 0)\nsetTimeout(()=&gt;{\nconsole.log(‘timer2’)\nPromise.resolve().then(function() {\nconsole.log(‘promise2’)\n})\n}, 0)\n浏览器端：timer1=&gt;promise1=&gt;timer2=&gt;promise2\n自己运行，这个结果没疑问；\n理论node端： timer1=&gt;timer2=&gt;promise1=&gt;promise2\n为啥实际运行却是和浏览器一样的结果：timer1=&gt;promise1=&gt;timer2=&gt;promise2</p>\n</div>",
            "title": "关于浏览器事件循环和node事件循环一些疑问，求解答",
            "last_reply_at": "2020-04-07T03:41:06.389Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 1628,
            "create_at": "2020-03-30T01:08:46.219Z",
            "author": {
                "loginname": "15537839367",
                "avatar_url": "https://avatars1.githubusercontent.com/u/29532906?v=4&s=120"
            }
        },
        {
            "id": "5e85b01664259617c49a41b7",
            "author_id": "5c37f3d6a4d44449266af96a",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>inquirer.js 执行的代码是一个回调 但是我想把回调的结果 通过module.exports 变得全局共享，谷歌了半天外加英文不算很好没有得到答案。inquirer.prompt(questions).then(answers=&gt;{\nmodule.exports = {\nanswers\n}\n})\n本意就是只需要执行一次inquirer.js 但是得到的结果我可以在任何文件里通过require的结果得到。有没有哪位同学尝试过</p>\n</div>",
            "title": "inquirer.js 怎么才能让答案变得全局共享",
            "last_reply_at": "2020-04-07T03:31:52.725Z",
            "good": false,
            "top": false,
            "reply_count": 5,
            "visit_count": 696,
            "create_at": "2020-04-02T09:27:50.520Z",
            "author": {
                "loginname": "wangi4myself",
                "avatar_url": "https://avatars3.githubusercontent.com/u/26651458?v=4&s=120"
            }
        },
        {
            "id": "5e8b54ae64259617c49a49ba",
            "author_id": "4efc278525fa69ac69000079",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><strong>Node.js 创建子进程的方法常用的有如下几种：</strong></p>\n<p><strong>child_process</strong></p>\n<ul>\n<li><a href=\"http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback\">exec</a>: 衍生一个 shell 然后在该 shell 中执行 <code>command</code>，并缓冲任何产生的输出，最大缓存1024*1024 个字节。</li>\n<li><a href=\"http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback\">execFile</a>: 函数类似<code>exec</code>，但默认情况下不会衍生 shell。 相反，指定的可执行文件<code>file</code> 会作为新进程直接地衍生，使其比<code>exec</code> 稍微更高效。和<code>exec</code>一样，它也有最大1024*1204个字节的显示缓存。</li>\n<li><a href=\"http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options\">fork</a>: 是 <code>spawn</code>的一个特例，专门用于衍生新的 Node.js 进程。 与<code>spawn</code>一样返回<code>ChildProcess</code>对象。 返回的<code>ChildProcess</code>将会内置一个额外的通信通道，允许消息在父进程和子进程之间来回传递。</li>\n<li><a href=\"http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options\">spawn</a>: 上诉的几个方法其实都是通过spawn实现的。</li>\n</ul>\n<p><strong>cluster</strong></p>\n<ul>\n<li><a href=\"http://nodejs.cn/api/cluster.html#cluster_cluster_fork_env\">fork</a>: 衍生出一个新的工作进程，这只能通过主进程调用。</li>\n</ul>\n<h3><strong>翻翻源码看看他们怎么实现的</strong></h3>\n<p>源码版本和之前的<a href=\"https://miser.github.io/2020/03/01/v8-libuv-timer-event-loop/\">libuv &amp; Node.js EventLoop （一）</a>一样</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; libuv\n#define UV_VERSION_MAJOR 1\n#define UV_VERSION_MINOR 33\n#define UV_VERSION_PATCH 1\n\n&#x2F;&#x2F; V8\n#define V8_MAJOR_VERSION 7\n#define V8_MINOR_VERSION 8\n#define V8_BUILD_NUMBER 279\n#define V8_PATCH_LEVEL 17\n\n&#x2F;&#x2F; Node.js\n#define NODE_MAJOR_VERSION 14\n#define NODE_MINOR_VERSION 0\n#define NODE_PATCH_VERSION 0\n</code></pre><p><strong>child_process</strong>源码位置</p>\n<pre class=\"prettyprint language-javascript\"><code>Node \n  - lib \n    - internal \n      - child_process.js \n    - child_process.js;\n</code></pre><p>在<code>lib/child_process.js</code>文件中，定义了<code>exec</code>、<code>execFile</code>、<code>fork</code>和<code>spawn</code>等方法，它们最后都会调用在<code>lib/internal/child_process.js</code>文件中的<code>spawn</code>方法。</p>\n<p><strong>exec</strong></p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; lib&#x2F;child_process.js\nfunction exec(command, options, callback) {\n  const opts = normalizeExecArgs(command, options, callback);\n  return module.exports.execFile(opts.file, opts.options, opts.callback);\n}\nfunction normalizeExecArgs(command, options, callback) {\n  if (typeof options === &quot;function&quot;) {\n    callback = options;\n    options = undefined;\n  }\n\n  &#x2F;&#x2F; Make a shallow copy so we don&#x27;t clobber the user&#x27;s options object.\n  options = { ...options };\n  options.shell = typeof options.shell === &quot;string&quot; ? options.shell : true;\n\n  return {\n    file: command,\n    options: options,\n    callback: callback,\n  };\n}\n</code></pre><p>从上面发现 exec 其实就是封装了参数，主要是开启<code>shell</code>参数，然后调用 execFile 方法。</p>\n<p><strong>execFile</strong></p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; lib&#x2F;child_process.js\nfunction execFile(file &#x2F;* , args, options, callback *&#x2F;) {\n  let args = [];\n  let callback;\n  let options;\n\n  &#x2F;&#x2F; ...\n\n  options = {\n    encoding: &quot;utf8&quot;,\n    timeout: 0,\n    maxBuffer: MAX_BUFFER,\n    killSignal: &quot;SIGTERM&quot;,\n    cwd: null,\n    env: null,\n    shell: false, &#x2F;&#x2F; execFile 默认是不开启shell\n    ...options,\n  };\n\n  &#x2F;&#x2F; 通过spawn方法创建子进程\n  const child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    gid: options.gid,\n    uid: options.uid,\n    shell: options.shell,\n    windowsHide: !!options.windowsHide,\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments,\n  });\n\n  var encoding;\n  const _stdout = []; &#x2F;&#x2F; 输出的内容\n  const _stderr = []; &#x2F;&#x2F; 出错的内容\n  &#x2F;&#x2F; ...\n  var stdoutLen = 0; &#x2F;&#x2F; 输出内容的长度\n  var stderrLen = 0; &#x2F;&#x2F; 出错内容的长度\n  var killed = false; &#x2F;&#x2F; 是否已经被杀死\n  var exited = false; &#x2F;&#x2F; 是否已经退出\n  var timeoutId; &#x2F;&#x2F; 是否有定时器\n\n  var ex = null; &#x2F;&#x2F; 出错的上下文对象\n\n  var cmd = file; &#x2F;&#x2F; 命令或文件\n\n  &#x2F;&#x2F; 退出回调方法\n  function exithandler(code, signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    &#x2F;&#x2F; merge chunks\n    var stdout;\n    var stderr;\n    if (encoding || (child.stdout &amp;&amp; child.stdout.readableEncoding)) {\n      stdout = _stdout.join(&quot;&quot;);\n    } else {\n      stdout = Buffer.concat(_stdout); &#x2F;&#x2F; 如果不传入 encoding 参数，默认是Buffer拼接输出\n    }\n    if (encoding || (child.stderr &amp;&amp; child.stderr.readableEncoding)) {\n      stderr = _stderr.join(&quot;&quot;);\n    } else {\n      stderr = Buffer.concat(_stderr); &#x2F;&#x2F; 如果不传入 encoding 参数，默认是Buffer拼接输出\n    }\n\n    if (!ex &amp;&amp; code === 0 &amp;&amp; signal === null) {\n      callback(null, stdout, stderr); &#x2F;&#x2F; 没有错误，执行回调\n      return;\n    }\n\n    if (args.length !== 0) cmd += &#96; ${args.join(&quot; &quot;)}&#96;;\n\n    if (!ex) {\n      &#x2F;&#x2F; eslint-disable-next-line no-restricted-syntax\n      ex = new Error(&quot;Command failed: &quot; + cmd + &quot;\\n&quot; + stderr);\n      ex.killed = child.killed || killed;\n      ex.code = code &lt; 0 ? getSystemErrorName(code) : code;\n      ex.signal = signal;\n    }\n\n    ex.cmd = cmd;\n    callback(ex, stdout, stderr); &#x2F;&#x2F; 有错误，执行回调\n  }\n\n  function errorhandler(e) {\n    ex = e;\n\n    &#x2F;&#x2F; child.stdout 和 child.stderr 都销毁\n    if (child.stdout) child.stdout.destroy();\n\n    if (child.stderr) child.stderr.destroy();\n\n    exithandler();\n  }\n\n  function kill() {\n    if (child.stdout) child.stdout.destroy();\n\n    if (child.stderr) child.stderr.destroy();\n\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exithandler();\n    }\n  }\n\n  &#x2F;&#x2F; 如果定义了子进程的超时时间，就定时销毁它\n  if (options.timeout &gt; 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }, options.timeout);\n  }\n\n  if (child.stdout) {\n    if (encoding) child.stdout.setEncoding(encoding);\n\n    child.stdout.on(&quot;data&quot;, function onChildStdout(chunk) {\n      const encoding = child.stdout.readableEncoding;\n      const length = encoding\n        ? Buffer.byteLength(chunk, encoding)\n        : chunk.length;\n      stdoutLen += length; &#x2F;&#x2F; 不断累加输出的长度\n\n      if (stdoutLen &gt; options.maxBuffer) {\n        &#x2F;&#x2F; 超过的话就报错\n        const truncatedLen = options.maxBuffer - (stdoutLen - length);\n        _stdout.push(chunk.slice(0, truncatedLen));\n\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(&quot;stdout&quot;);\n        kill();\n      } else {\n        _stdout.push(chunk); &#x2F;&#x2F; 不断累积chunk\n      }\n    });\n  }\n\n  &#x2F;&#x2F; 整体逻辑和上面的child.stdout基本一致\n  if (child.stderr) {\n    if (encoding) child.stderr.setEncoding(encoding);\n\n    child.stderr.on(&quot;data&quot;, function onChildStderr(chunk) {\n      const encoding = child.stderr.readableEncoding;\n      const length = encoding\n        ? Buffer.byteLength(chunk, encoding)\n        : chunk.length;\n      stderrLen += length;\n\n      if (stderrLen &gt; options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stderrLen - length);\n        _stderr.push(chunk.slice(0, truncatedLen));\n\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(&quot;stderr&quot;);\n        kill();\n      } else {\n        _stderr.push(chunk);\n      }\n    });\n  }\n\n  child.addListener(&quot;close&quot;, exithandler);\n  child.addListener(&quot;error&quot;, errorhandler);\n\n  return child;\n}\n</code></pre><p><code>exec</code>和<code>execFile</code>最大的一个区别就是参数<code>shell</code>默认是否开启，其它基本都是相同的。另外，它们对输出的内容有大小限制是在<code>child.stderr.on('data')</code>和<code>child.stdout.on('data')</code>获取数据时候被限制。</p>\n<p>如果不做类似的规定，<code>_stderr</code>和<code>_stdout</code>无限被输出，那么内存会不断的膨胀导致性能问题，甚至程序奔溃。（这是我猜的原因）</p>\n<p>另外说到底，<strong>最后还是对<code>spawn</code>方法的封装了调用。</strong></p>\n<p><strong>fork</strong></p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; lib&#x2F;child_process.js\nfunction fork(modulePath &#x2F;* , args, options *&#x2F;) {\n  &#x2F;&#x2F; Get options and args arguments.\n  var execArgv;\n  var options = {};\n  var args = [];\n\n  &#x2F;&#x2F; ...\n\n  &#x2F;&#x2F; fork方法的stdio参数，必须带有一个ipc参数\n  if (typeof options.stdio === &quot;string&quot;) {\n    options.stdio = stdioStringToArray(options.stdio, &quot;ipc&quot;);\n  } else if (!Array.isArray(options.stdio)) {\n    &#x2F;&#x2F; Use a separate fd=3 for the IPC channel. Inherit stdin, stdout,\n    &#x2F;&#x2F; and stderr from the parent if silent isn&#x27;t set.\n    options.stdio = stdioStringToArray(\n      options.silent ? &quot;pipe&quot; : &quot;inherit&quot;,\n      &quot;ipc&quot;\n    );\n  } else if (!options.stdio.includes(&quot;ipc&quot;)) {\n    throw new ERR_CHILD_PROCESS_IPC_REQUIRED(&quot;options.stdio&quot;);\n  }\n\n  options.execPath = options.execPath || process.execPath; &#x2F;&#x2F; 默认用父进程的Node执行文件\n  options.shell = false; &#x2F;&#x2F; 不开启 shell\n\n  return spawn(options.execPath, args, options);\n}\n</code></pre><p>从上面代码有个非常引人注意就是 12~22 行，fork 方法的 stdio 参数，必须带有一个 ipc 参数，这个<code>ipc</code>的作用将在后续深入挖掘后介绍。最后也是调用<code>spawn</code>创建子进程。</p>\n<p>&lt;br/&gt;</p>\n<p><strong>spawn</strong></p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; lib&#x2F;child_process.js\nfunction spawn(file, args, options) {\n  const child = new ChildProcess();\n\n  options = normalizeSpawnArguments(file, args, options);\n  debug(&quot;spawn&quot;, options);\n  child.spawn(options);\n\n  return child;\n}\n</code></pre><p><code>lib/child_process.js</code>里的 spawn 方法就简单的将传入的参数做整理，然后直接调用 ChildProcess 实例对象的 spawn。</p>\n<p><strong>ChildProcess</strong></p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; &#96;lib&#x2F;internal&#x2F;child_process.js&#96;\nfunction ChildProcess() {\n  EventEmitter.call(this);\n\n  &#x2F;&#x2F; ...\n\n  this._handle = new Process(); &#x2F;&#x2F; new 出一个 ProcessWrap 对象 （ process_wrap.cc）\n}\n\nChildProcess.prototype.spawn = function (options) {\n  let i = 0;\n\n  &#x2F;&#x2F; 默认使用 pipe\n  let stdio = options.stdio || &quot;pipe&quot;;\n\n  &#x2F;&#x2F; 重置stdio变量，这个是个很重要的方法，后续将继续介绍\n  stdio = getValidStdio(stdio, false);\n\n  const ipc = stdio.ipc;\n  const ipcFd = stdio.ipcFd;\n  stdio = options.stdio = stdio.stdio;\n\n  &#x2F;&#x2F; ...\n\n  &#x2F;&#x2F; 调用ProcessWrap对应的spawn去创建新进程\n  const err = this._handle.spawn(options);\n\n  &#x2F;&#x2F; 如果err存在，就会有相关代码处理创建子进程出错的场景\n  &#x2F;&#x2F; ...\n\n  this.pid = this._handle.pid;\n\n  for (i = 0; i &lt; stdio.length; i++) {\n    const stream = stdio[i];\n    &#x2F;&#x2F; ...\n    if (stream.handle) {\n      &#x2F;&#x2F; When i === 0 - we&#x27;re dealing with stdin\n      &#x2F;&#x2F; (which is the only one writable pipe).\n      &#x2F;&#x2F; 创建 socket\n      stream.socket = createSocket(\n        this.pid !== 0 ? stream.handle : null,\n        i &gt; 0\n      );\n\n      if (i &gt; 0 &amp;&amp; this.pid !== 0) {\n        this._closesNeeded++;\n        stream.socket.on(&quot;close&quot;, () =&gt; {\n          maybeClose(this);\n        });\n      }\n    }\n  }\n  this.stdin =\n    stdio.length &gt;= 1 &amp;&amp; stdio[0].socket !== undefined ? stdio[0].socket : null;\n  this.stdout =\n    stdio.length &gt;= 2 &amp;&amp; stdio[1].socket !== undefined ? stdio[1].socket : null;\n  this.stderr =\n    stdio.length &gt;= 3 &amp;&amp; stdio[2].socket !== undefined ? stdio[2].socket : null;\n\n  this.stdio = [];\n\n  for (i = 0; i &lt; stdio.length; i++)\n    this.stdio.push(stdio[i].socket === undefined ? null : stdio[i].socket);\n\n  &#x2F;&#x2F; Add .send() method and start listening for IPC data\n  &#x2F;&#x2F; setupChannel 方法很长，主要就是实现了数据的发送和接受\n  if (ipc !== undefined) setupChannel(this, ipc);\n\n  return err;\n};\n\nfunction stdioStringToArray(stdio, channel) {\n  &#x2F;&#x2F; 主要将stdio参数格式化为[xxx,xxx,xxx]形式的数组\n  &#x2F;&#x2F; 如果有channel，[xxx,xxx,xxx,channel]\n}\n\nfunction getValidStdio(stdio, sync) {\n  var ipc;\n  var ipcFd;\n\n  stdio = stdio.reduce((acc, stdio, i) =&gt; {\n    function cleanup() {\n      for (var i = 0; i &lt; acc.length; i++) {\n        if ((acc[i].type === &quot;pipe&quot; || acc[i].type === &quot;ipc&quot;) &amp;&amp; acc[i].handle)\n          acc[i].handle.close();\n      }\n    }\n\n    if (stdio === &quot;ignore&quot;) {\n      acc.push({ type: &quot;ignore&quot; }); &#x2F;&#x2F; 子进程的输出不需要在控制台显示\n    } else if (stdio === &quot;pipe&quot; || (typeof stdio === &quot;number&quot; &amp;&amp; stdio &lt; 0)) {\n      var a = {\n        type: &quot;pipe&quot;,\n        readable: i === 0, &#x2F;&#x2F; 0是stdin，需要读\n        writable: i !== 0, &#x2F;&#x2F; 1是stdout，2是stderr 需要写\n      };\n      &#x2F;&#x2F; spawn 调用的时候，sync为false，为stdin、stdout、stderr创建一个SOCKET类型Pipe\n      if (!sync) a.handle = new Pipe(PipeConstants.SOCKET);\n\n      acc.push(a);\n    } else if (stdio === &quot;ipc&quot;) {\n      &#x2F;&#x2F; 创建一个IPC类型Pipe\n      ipc = new Pipe(PipeConstants.IPC);\n      ipcFd = i; &#x2F;&#x2F; ipc位置\n\n      acc.push({\n        type: &quot;pipe&quot;,\n        handle: ipc,\n        ipc: true,\n      });\n    } else if (stdio === &quot;inherit&quot;) {\n      acc.push({\n        type: &quot;inherit&quot;,\n        fd: i,\n      });\n    }\n    &#x2F;&#x2F; ...还有很多代码，不在讨论范围\n    return acc;\n  }, []);\n\n  return { stdio, ipc, ipcFd };\n}\n</code></pre><p><code>ChildProcess</code>并不能直接创建新的进程，需要底层 V8 的帮助，在构造函数里面直接 new ProcessWrap 赋给了 this._handle。</p>\n<p><code>ChildProcess.prototype.spawn</code>开始主要处理主要的<a href=\"http://nodejs.cn/api/child_process.html#child_process_options_stdio\"><code>stdio</code></a>参数，明确父子进程通过哪些方式来获取数据信息，官方文档给出了一些示例，如果不清楚可以多做点实验。如果是<code>pipe</code>或者是<code>ipc</code>都会实例化一个 Pipe 对象，只是参数类型不同。</p>\n<pre class=\"prettyprint language-c\"><code>&#x2F;&#x2F; pipe_wrap.cc\nvoid PipeWrap::New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  switch (type) {\n    case SOCKET:\n      provider = PROVIDER_PIPEWRAP;\n      ipc = false;\n      break;\n    case IPC:\n      provider = PROVIDER_PIPEWRAP;\n      ipc = true;\n      break;\n  }\n  new PipeWrap(env, args.This(), provider, ipc);\n}\nPipeWrap::PipeWrap(Environment* env,\n                   Local&lt;Object&gt; object,\n                   ProviderType provider,\n                   bool ipc)\n    : ConnectionWrap(env, object, provider) {\n  int r = uv_pipe_init(env-&gt;event_loop(), &amp;handle_, ipc);\n}\n&#x2F;&#x2F; deps&#x2F;uv&#x2F;src&#x2F;unix&#x2F;pipe.c\nint uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int ipc) {\n  uv__stream_init(loop, (uv_stream_t*)handle, UV_NAMED_PIPE);\n  handle-&gt;shutdown_req = NULL;\n  handle-&gt;connect_req = NULL;\n  handle-&gt;pipe_fname = NULL;\n  handle-&gt;ipc = ipc;\n  return 0;\n}\n</code></pre><p>它们唯一的区别就是<code>uv_pipe_t</code>的 ipc 参数是 true 还是 false，<strong>所有的事件都被老老实实的绑定在 libuv 上</strong>。</p>\n<p>回到<code>ChildProcess.prototype.spawn</code>中，已经重置了 stdio 参数后，到了真正创建子进程的地方了，<code>this._handle.spawn(options);</code>，通过<code>process_wrap.cc</code>里的 ProcessWrap.Spawn 去创建，整个创建方法也极长，主要是对传入的参数进行处理，然后再调用<code>uv_spawn</code>。</p>\n<pre class=\"prettyprint language-c\"><code>&#x2F;&#x2F; deps&#x2F;uv&#x2F;src&#x2F;unix&#x2F;process.c\nint uv_spawn(uv_loop_t* loop,\n             uv_process_t* process,\n             const uv_process_options_t* options) {\n#if defined(__APPLE__) &amp;&amp; (TARGET_OS_TV || TARGET_OS_WATCH)\n  &#x2F;* fork is marked __WATCHOS_PROHIBITED __TVOS_PROHIBITED. *&#x2F;\n  return UV_ENOSYS;\n#else\n  &#x2F;&#x2F; ...\n\n  uv_signal_start(&amp;loop-&gt;child_watcher, uv__chld, SIGCHLD);\n\n  &#x2F;* Acquire write lock to prevent opening new fds in worker threads *&#x2F;\n  uv_rwlock_wrlock(&amp;loop-&gt;cloexec_lock);\n  pid = fork();\n\n  if (pid == -1) {\n    err = UV__ERR(errno);\n    uv_rwlock_wrunlock(&amp;loop-&gt;cloexec_lock);\n    uv__close(signal_pipe[0]);\n    uv__close(signal_pipe[1]);\n    goto error;\n  }\n\n  if (pid == 0) {\n    uv__process_child_init(options, stdio_count, pipes, signal_pipe[1]);\n    abort();\n  }\n\n  &#x2F;* Release lock in parent process *&#x2F;\n  uv_rwlock_wrunlock(&amp;loop-&gt;cloexec_lock);\n  uv__close(signal_pipe[1]);\n\n  &#x2F;&#x2F; ...\n}\n</code></pre><p>通过系统层面的<code>fork</code>函数创建子进程，由于 fork 的特殊性，一次调用返回二次，当返回 0 的时候回执行子进程的逻辑，回去通过<code>uv__process_child_init</code>初始化整个子进程的上下文信息。</p>\n<p>再回到<code>ChildProcess.prototype.spawn</code>中，遍历<code>stdio</code>，如果成员有 handle 字段，就通过<code>createSocket</code>为其创建一个 socket 对象</p>\n<pre class=\"prettyprint language-javascript\"><code>function createSocket(pipe, readable) {\n  return net.Socket({ handle: pipe, readable, writable: !readable });\n}\n</code></pre><p>无论是参数<code>stdio</code>是 pipe 还是 ipc 都会创建 socket，在父子进程通信的时候，父进程通过子进程暴露出来的 stdin、stdout 和 stderr 来展示子进程执行的信息，缺乏之间的数据互通性，这也是导致<code>exec</code>和<code>execFile</code>可使用的场景有限，而<code>fork</code>会带一个 ipc 参数给 stdio 参数（可以回过去翻翻 fork 源码），所以可以执行父子进程的通信操作，比如 send 方法等，具体的实现可以看<code>setupChannel</code>。</p>\n<p><strong>综上</strong>，Node.js 在<code>child_process</code>里创建进程的流程大致梳理了下，在 JavaScript 层面并没有什么复杂的，在 libuv 层面注册了很多相关的事件，有空可以研究研究。之后会写一篇关于 cluster.fork 的介绍，其实就是对 child_process.fork 更多的封装。</p>\n</div>",
            "title": "简答梳理Node.js启动子进程的方法（上）",
            "last_reply_at": "2020-04-06T16:11:26.052Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 1328,
            "create_at": "2020-04-06T16:11:26.052Z",
            "author": {
                "loginname": "miser",
                "avatar_url": "//gravatar.com/avatar/80e9e34cd2f4e1ec89ff2f8f386139dd?s=48"
            }
        },
        {
            "id": "5e88646758ab6717beb7e251",
            "author_id": "5ab852d6320bb09d69e231f1",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>同样的运行cmd代码在Windows 7上是好用的,迁移到Windows server 2012上就不好用,到底为什么啊?麻烦大家了…能帮忙解答一下么?</p>\n<p>let cmd = “tesseract &quot; + imgPath + &quot; stdout -l eng -c tessedit_char_whitelist=0123456789”;\n这个cmd的值,直接复制到cmd命令窗口是好用的…经过node的exec就不好用了</p>\n<p>报出错误:\nCommand failed: tesseract H:\\orc\\tesseract\\codeImages\\1.png stdout -l eng -c tessedit_char_whitelist=0123456789\n’tesseract’ �����ڲ����ⲿ���Ҳ���ǿ����еĳ���\n这后面还一堆乱码~~~</p>\n<p><img src=\"//static.cnodejs.org/Fh2A9b3L44S-9ha3fob-w9cHkSqm\" alt=\"zz.png\"></p>\n</div>",
            "title": "请大神帮忙,node12使用exec运行CMD命令不好用",
            "last_reply_at": "2020-04-06T14:02:24.812Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 612,
            "create_at": "2020-04-04T10:41:43.899Z",
            "author": {
                "loginname": "iori2882",
                "avatar_url": "https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"
            }
        },
        {
            "id": "5e8b15c264259617c49a4949",
            "author_id": "53f5437fbbdaa79d51bb50a3",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>最近持续 github 上的项目持续收到依赖包的黄色警告， 于是做了个工具来查看哪个根依赖包在用这些中招的包，然后发现黄色警告只是冰山一角罢了。\n安装：\n<code>npm install whodeps -g</code></p>\n<p>cd 到你项目目录下，目录下必须有<code>package.json</code> <code>package-lock.json</code>。\n然后 <code>whodeps</code> 想查看的依赖 + 版本上限。\n例\n<code>whodeps kind-of 6.0.0</code>\n<img src=\"//static.cnodejs.org/Fnp9kMF62D_8WxGQ5rwOoA5cCxYg\" alt=\"abc2.gif\"></p>\n<p>项目地址：<a href=\"https://github.com/hezedu/whodeps\">https://github.com/hezedu/whodeps</a></p>\n</div>",
            "title": "使用 whodeps 查看你的项目依赖包到底多少中招",
            "last_reply_at": "2020-04-06T11:42:58.389Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 1399,
            "create_at": "2020-04-06T11:42:58.389Z",
            "author": {
                "loginname": "hezedu",
                "avatar_url": "https://avatars2.githubusercontent.com/u/8508437?v=4&s=120"
            }
        },
        {
            "id": "5e8ad9a758ab6717beb7e4fe",
            "author_id": "5a3b17649807389a1809f5a5",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>有的集合数据量不大，没有设置片键，那在mongodb分片集群中是怎么存储的呢？</p>\n</div>",
            "title": "mongodb分片，如果一个集合没有片键，存储查询时是怎么做的呢？",
            "last_reply_at": "2020-04-06T07:26:31.958Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 1445,
            "create_at": "2020-04-06T07:26:31.958Z",
            "author": {
                "loginname": "Sxy97",
                "avatar_url": "https://avatars3.githubusercontent.com/u/24429847?v=4&s=120"
            }
        },
        {
            "id": "5e8a8cf858ab6717beb7e47a",
            "author_id": "5df4fc9328dce75de5435c0e",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>wolf是一个统一认证及授权(RBAC)管理的系统. 主要适用于后台系统.  项目最近支持了apisix网关.</p>\n<ul>\n<li>项目介绍在这里<a href=\"https://github.com/iGeeky/wolf\">https://github.com/iGeeky/wolf</a></li>\n<li>apisix插件在这里<a href=\"https://github.com/apache/incubator-apisix/blob/master/doc/plugins/wolf-rbac-cn.md\">wolf-rbac</a>. (apisix是一个非常优秀的网关)</li>\n</ul>\n<p>项目介绍跟基本功能这里就不帖了, 大家直接访问Github吧.</p>\n<p>基本的认证及授权管理功能,目前使用起来已经比较顺畅. 发帖目的是希望大家能试用, 并提出意见. 希望在大家使用与反馈中, 能让系统逐渐完善与完美.</p>\n</div>",
            "title": "统一认证及授权管理系统Wolf, 现在支持apisix了. 请大家多提意见与建议.",
            "last_reply_at": "2020-04-06T03:54:26.514Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 475,
            "create_at": "2020-04-06T01:59:20.822Z",
            "author": {
                "loginname": "iGeeky",
                "avatar_url": "https://avatars0.githubusercontent.com/u/57409417?v=4&s=120"
            }
        },
        {
            "id": "5e8aa64058ab6717beb7e49b",
            "author_id": "5e5bc6cea72b853f10045418",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>Laravel+Vue 实在开发 Youtube 最近再学这个，感觉不错\n推荐大家看看，地址：\n<a href=\"http://study.tongpankt.com/course/20\">Laravel+Vue 实战开发 YouTube</a></p>\n</div>",
            "title": "Laravel+Vue 实战开发 YouTube 最近再学这个，感觉不错",
            "last_reply_at": "2020-04-06T03:47:12.609Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 1321,
            "create_at": "2020-04-06T03:47:12.609Z",
            "author": {
                "loginname": "tongpan0",
                "avatar_url": "https://avatars2.githubusercontent.com/u/20548644?v=4&s=120"
            }
        },
        {
            "id": "5e7d330c64259617c49a3156",
            "author_id": "5313f9c82a5b081d6c07004a",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>考虑是否学习下NodeJs<img src=\"//static.cnodejs.org/Fr4eEtQLogIbRL_7SojWSS2M5QGd\" alt=\"QQ图片20200327065143.png\"></p>\n</div>",
            "title": "据说用NodeJS开发某币效率很高，真的吗",
            "last_reply_at": "2020-04-05T07:32:03.959Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 2584,
            "create_at": "2020-03-26T22:56:12.858Z",
            "author": {
                "loginname": "dongguangming",
                "avatar_url": "https://avatars0.githubusercontent.com/u/6701712?v=4&s=120"
            }
        },
        {
            "id": "5e7c42cf64259617c49a2f58",
            "author_id": "5e77777464259617c49a245e",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>我参与创立过好几个创业项目了，在美国研究生毕业之后拒掉了google的offer，作为技术合伙人和朋友一起创立了第一个正儿八经的创业公司，做跨境电商，还进了硅谷的孵化器Plug and Play. 后来拿了真格基金的投资，整个团队一起从旧金山湾区搬迁回了北京，在五道口租了一个小民居干了两年。</p>\n<p>后来因为各种原因，第一个项目没成。那个时候是2016年，北京还是创业潮正热的时候，我很快就被拉入了一个新的创业项目，做零售相关to b 的sass服务。这个项目已经做了一段时间了，有一些不错的成绩，但一直缺一个CTO，产品跑不起来，我当时加入进去也觉得充满了信心。</p>\n<p>然后就是三年的高节奏996生活，加班到半夜两三点甚至是通宵都是常态，在北京的创业圈这也没什么好说的，大家都这样。中间也经历过好几次产品发布、销售增长、还有融资的高光时刻，一直到去年夏天，团队才开始慢慢分崩离析，个中原因不便多说，我也是下了很大决心才决定离开，创过业的人们应该都懂。</p>\n<p>去年夏天决定离开北京，也开始了digital nomad 数字游民的生活，也回到美国呆了一段时间，想了很多。去年满30岁，我在想自己到底想要什么样的生活。有时候也会想，如果当时留在美国、去了google工作现在是不是会是一种完全不同的生活，但我也并不后悔，这些年的经历都是难能可贵的，也知道了很多时候事在人为，一些所谓的成就可能只是恰好踩在了风口上，运气好罢了。</p>\n<p>在创业圈呆久了，思维有时候都比较僵化，一想到“创业”就是千万融资、组建团队、媒体报道等等。后来慢慢了解到了indie hacker和数字游民的圈子，发现不仅是美国还有国内，都有很多优秀的独立开发者，他们一边做着优质的 产品，一边也获得着不错的收益，能自己掌握自己的生活节奏，可以说是非常理想的状态了，我也希望能跟他们一样。</p>\n<p>于是开始着手做一些自己感兴趣的项目。我也算是比较早地在美国接触到hackathon的文化，这些年也做过很多side project，但每次启动项目都会重复配置, 启动database, nginx, gunicorn, redis等等。所以我把一直想做的事情做了————写了一个内部系统统一管理，把很多事情自动化，其实主要是为了方便自己。</p>\n<p>最近有朋友看到这个系统后问有没有方法让他也能用上，我想可能其他独立开发者也会有这样的需要，所以就封装了一下，做成了一个产品。UX/UI很简单，简单点几下就能把要的数据库、web service 启动起来。除了流程简化，定价比起阿里云、腾讯云之类的也便宜很多，我有朋友知道价格之后果断退掉了阿里云剩余的服务，把数据库和服务器都搬了过来。（我也才知道原来阿里云是支持随时退款的，具体看这里：<a href=\"https://help.aliyun.com/knowledge_detail/116043.html?spm=a2c81.e1d666e.app.1.62ae1127wa48mb\">https://help.aliyun.com/knowledge_detail/116043.html?spm=a2c81.e1d666e.app.1.62ae1127wa48mb</a>）</p>\n<p>因为自己是技术出身，所以一直以来都比较缺乏business mind，现在自己一个人做项目了，越来越意识到技术只是手段，时间应该专注到业务逻辑上，和用户交流、去获取反馈，而不应该浪费时间去做配置、反复处理不同环境或运维的问题。</p>\n<h2>产品</h2>\n<p>产品刚上线不久，目前只支持下面几个功能:</p>\n<ul>\n<li>\n<p>读取 Github repos, 自动最新代码，点部署完成构建!\n目前只支持 Github。(前段时间在v站发<a href=\"https://www.v2ex.com/t/622604#reply104\">post</a>。Github 还是最多人用，后续如果反应好，把 Gitlab, Coding 等等也支持一下)</p>\n</li>\n<li>\n<p>在 docker 集群里构建项目和启动项目。\n目前支持 <code>Node</code>, <code>Python</code>, 数据库 <code>PostgreSQL</code> / <code>MySQL</code>, 各种静态页(<code>vue.js</code>, <code>react.js</code>等)</p>\n</li>\n<li>\n<p>生成的服务都有 HTTPS 和永久免费二级子网名 (如 <a href=\"https://flask.21yunbox.com\">https://flask.21yunbox.com</a>)</p>\n</li>\n</ul>\n<p><strong>如果你也想快速启动项目，不想浪费时间处理运维和启动工作，可以试一下！</strong></p>\n<h2>福利时间</h2>\n<p>最后，也为 <strong>cnode</strong> 的兄弟姐妹们提供了一个独家优惠，主要也是为了让更多人用到、能收集更多反馈！</p>\n<ul>\n<li>网站地址：<a href=\"https://21yunbox.com\">https://21yunbox.com</a></li>\n<li>优惠内容：30元代金券</li>\n<li>优惠方式：加我微信或从网站上的联系方式找我，备注 <strong><code>cnode</code></strong> 即可</li>\n<li>也欢迎大家加我微信交流创业、独立开发、数字游民等各种相关话题！</li>\n</ul>\n</div>",
            "title": "从硅谷到北京再到东南亚，为自己而工作的307天",
            "last_reply_at": "2020-04-03T10:34:04.218Z",
            "good": false,
            "top": false,
            "reply_count": 5,
            "visit_count": 2615,
            "create_at": "2020-03-26T05:51:11.668Z",
            "author": {
                "loginname": "tobyglei",
                "avatar_url": "https://avatars3.githubusercontent.com/u/50851460?v=4&s=120"
            }
        },
        {
            "id": "554b63fdb68166372e600138",
            "author_id": "5548c9b572eab93b431d0d34",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>Cnode有一个N次浏览功能，自己在自己话题下不断的F5浏览数会不断的增加，无ip区别？</p>\n</div>",
            "title": "Cnode社区浏览数问题",
            "last_reply_at": "2020-04-03T10:23:15.035Z",
            "good": false,
            "top": false,
            "reply_count": 11,
            "visit_count": 204423,
            "create_at": "2015-05-07T13:09:17.675Z",
            "author": {
                "loginname": "songqinghehe",
                "avatar_url": "https://avatars.githubusercontent.com/u/12146443?v=3&s=120"
            }
        },
        {
            "id": "5e6882c33cadb020b91607e2",
            "author_id": "5e68538e3cadb020b916070b",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>最近病毒闹得很厉害，在家没事情做，所以用了一个多月的时间做了一个简单的论坛项目练手，但是发现东西还是挺多了，一个人忙不过来，不知道大家有没有兴趣一起做下。</p>\n<p>目前项目是基本上大概的流程都已经走通了：</p>\n<ul>\n<li>用户注册，登录</li>\n<li>个人信息修改、修改密码</li>\n<li>个人信息查看</li>\n<li>发帖、回贴、编辑</li>\n<li>帖子列表查看帖子、点赞</li>\n</ul>\n<p>目前计划还需要增加：</p>\n<ol>\n<li>用户分组权限</li>\n<li>包括搜索（准备用ES）</li>\n<li>第三方平台登录</li>\n<li>Session管理（redis）</li>\n<li>论坛管理：版面，用户，帖子</li>\n</ol>\n<p>等功能还未做</p>\n<p>目前项目是前后端分离的：</p>\n<p>数据库：mysql，redis，计划加上ES做搜索\n前端：react+nextjs+antd做的SSR，mobx做的状态管理\n后端：KOA做的API服务并且apidoc做了接口文档生成</p>\n<p>不知道大家有没有兴趣一起练练手，至少做成一个稍微成熟可用的项目</p>\n<p>目前项目地址：<a href=\"https://github.com/deep-course/shallow-forum\">https://github.com/deep-course/shallow-forum</a></p>\n<p>我一个人主要偏后端，react会一些简单的\n所以有没有以下的小伙伴一起来搞下：</p>\n<p><strong>会react的前端</strong>：这个是最主要的，我前端水平一般\n<strong>后端</strong>：后端基本上我都能搞定，所以只要了解一些相关的开发就行\n<strong>产品</strong>：有小伙伴帮忙整理下文档，因为一直开发，文档方面一直都忽视了</p>\n<p>如果大家感兴趣，欢迎大佬和小伙伴一起来练手</p>\n</div>",
            "title": "开源轻论坛（nodejs）练手，有没没有想做开源项目的朋友一起搞下",
            "last_reply_at": "2020-04-03T10:18:15.454Z",
            "good": false,
            "top": false,
            "reply_count": 14,
            "visit_count": 3955,
            "create_at": "2020-03-11T06:18:43.358Z",
            "author": {
                "loginname": "zergtant",
                "avatar_url": "https://avatars1.githubusercontent.com/u/6510464?v=4&s=120"
            }
        },
        {
            "id": "5e6b4baf3cadb020b9160e04",
            "author_id": "5cab188c7edd13064e05363f",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>vue 自带的ssr 或nuxt\nreact的 next\nreact-egg-ssr\n有人提过的 在dns那里区分，\nnuxt 或者 next 又有性能问题。。。</p>\n<p>那么到底有没有一种终极解决方案呢，，，又开发起来舒服，性能又不差，还能满足seo需求，，，，，</p>\n</div>",
            "title": "有seo 需求，的电商网站的前台页面，ssr的终极解决方案， 是啥。",
            "last_reply_at": "2020-04-03T08:57:30.383Z",
            "good": false,
            "top": false,
            "reply_count": 16,
            "visit_count": 3495,
            "create_at": "2020-03-13T09:00:31.940Z",
            "author": {
                "loginname": "ganshiqingyuan",
                "avatar_url": "https://avatars0.githubusercontent.com/u/33950951?v=4&s=120"
            }
        },
        {
            "id": "5e815a7f58ab6717beb7d460",
            "author_id": "53e1802fbd3cc3e50ba9e311",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>事件概述：<a href=\"https://mp.weixin.qq.com/s/gAdQYDYsXRHoqGGEeit5CA\">core-js作者入狱18个月，月下载量过亿的npm包或将无人维护</a></p>\n<blockquote>\n<p>core-js 的作者 Denis Pushkarev 因驾驶摩托车撞人致1伤1亡，被判处有期徒刑 18 个月，剥夺 2 年驾驶权利，另处以罚金 138 万卢布。</p>\n</blockquote>\n<p>现在几乎 80% 的前端项目都直接或者间接使用到了 core-js。</p>\n</div>",
            "title": "core-js 作者入狱 18 个月对前端会有什么影响？",
            "last_reply_at": "2020-04-03T08:22:04.987Z",
            "good": false,
            "top": false,
            "reply_count": 9,
            "visit_count": 2532,
            "create_at": "2020-03-30T02:33:35.373Z",
            "author": {
                "loginname": "justjavac",
                "avatar_url": "https://avatars1.githubusercontent.com/u/359395?v=4&s=120"
            }
        },
        {
            "id": "5e3ea3ec1225c9423dcd99ee",
            "author_id": "528a32b1d2b3893f2a6aceeb",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><a href=\"https://angular.io/\">https://angular.io/</a></p>\n</div>",
            "title": "Angular 9.0 全面升级正式发布！",
            "last_reply_at": "2020-04-03T07:45:21.067Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 2432,
            "create_at": "2020-02-08T12:05:00.174Z",
            "author": {
                "loginname": "Hanggi",
                "avatar_url": "https://avatars2.githubusercontent.com/u/5997900?v=4&s=120"
            }
        },
        {
            "id": "5e81c7b264259617c49a3980",
            "author_id": "5cf726571fe902120f31c3a5",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>请教社区里的nodeJS大神，客观条件，我手里有服务器的 root 用户名和密码，一个普通用户名密码。和即将要装的 mysql 要设置的用户名密码，怎么实现变成三个接口分别跟 java 取请求数据，后面的返回给前端的我会</p>\n</div>",
            "title": "nodejs问题",
            "last_reply_at": "2020-04-03T06:16:57.406Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 1439,
            "create_at": "2020-03-30T10:19:30.529Z",
            "author": {
                "loginname": "SquabbyZ",
                "avatar_url": "https://avatars0.githubusercontent.com/u/43177939?v=4&s=120"
            }
        },
        {
            "id": "5e855c3358ab6717beb7dcd5",
            "author_id": "5066f99601d0b801487faa1a",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>看egg.js的官方文档里，指出controller是负责处理用户请求的参数的，然后传递到service里进行后续处理。我想问下，在service里直接通过获取ctx.query或者ctx.params进行处理合适吗？\n比如：我需要获取一个列表数据，我写一个getList的service，同时这个列表数据支持排序，所以我应该直接在service里获取order_by的值，还是现在controller里获取再传递给service比较好？</p>\n<p>在controller里获取query参数</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; app&#x2F;controller&#x2F;user.js\nconst Controller = require(&#x27;egg&#x27;).Controller;\nclass UserController extends Controller {\n  async index() {\n    const { ctx } = this;\n    const orderBy = ctx.query.order_by;\n    const userList = await ctx.service.user.getList(orderBy);\n    ctx.body = userList;\n  }\n}\nmodule.exports = UserController;\n\n&#x2F;&#x2F; app&#x2F;service&#x2F;user.js\nconst Service = require(&#x27;egg&#x27;).Service;\n\nclass UserService extends Service {\n  async getList(order) {\n    const users = await this.ctx.db.query(&#x27;select * from user order by &#x27;, order);\n    return user;\n  }\n}\nmodule.exports = UserService;\n</code></pre><p>PK</p>\n<p>在service里获取query参数</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; app&#x2F;controller&#x2F;user.js\nconst Controller = require(&#x27;egg&#x27;).Controller;\nclass UserController extends Controller {\n  async index() {\n    const { ctx } = this;\n    const userList = await ctx.service.user.getList();\n    ctx.body = userList;\n  }\n}\nmodule.exports = UserController;\n\n&#x2F;&#x2F; app&#x2F;service&#x2F;user.js\nconst Service = require(&#x27;egg&#x27;).Service;\n\nclass UserService extends Service {\n  async getList() {\n  \tconst order = this.ctx.query.order_by;\n    const users = await this.ctx.db.query(&#x27;select * from user order by &#x27;, order);\n    return user;\n  }\n}\nmodule.exports = UserService;\n</code></pre></div>",
            "title": "关于egg.js里service的最佳实践，是否可以在service里处理请求参数？",
            "last_reply_at": "2020-04-02T13:03:56.167Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 752,
            "create_at": "2020-04-02T03:29:55.679Z",
            "author": {
                "loginname": "elicip",
                "avatar_url": "//gravatar.com/avatar/0f1b6452df3cd1043fbdc1fbb9602fb4?size=48"
            }
        },
        {
            "id": "5e8468d664259617c49a3f20",
            "author_id": "59aa34b3ea0aea6b0c64e731",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><blockquote>\n<p>MareWood 是一个轻量级的前端部署工具，使用了 GOLANG、GIN、GORM、SQLITE、JWT、REACE、MATERIAL-UI 开发， 不同于 Jenkins 的大而全，它很简单且只针对前端，你可以很灵活的配置各种部署环境。 如果你愿意，线上发布也可以是点击一下按钮这么简单的事情,当然也可以配置 WEBHOOK，提交 GIT 代码既自动发布。</p>\n</blockquote>\n<p>开源地址：<a href=\"https://github.com/xusenlin/MareWood\" title=\"https://github.com/xusenlin/MareWood\">https://github.com/xusenlin/MareWood</a></p>\n<hr>\n<p>这件事还得从一只蝙蝠说起…（省略2万字）。然后，大家都开启了远程办公，后端家里网也没有穿透，每次调试 BUG 就要打包给后端或者不停的去运行 Linux 命令去部署不同的环境，可能一会后端、前端、测试小伙伴就会叫你打包，其中有一天，我做的工作最多的就是打包了，哈哈哈。</p>\n<hr>\n<p>当然，我们也有 Jenkins ，但是对于前端来说不太友好，因为需要插件，使用也不那么直观，部署好了也找不到访问的网址，每次都需要后端帮忙新建项目。因此，我决定开发一个针对前端的部署工具，界面足够漂亮，安装足够简单，使用足够方便。</p>\n<hr>\n<p>为了简单干净，技术栈使用了 GOLANG、GIN、GORM、SQLITE、JWT、REACE、MATERIAL-UI \n有了工具之后，每次我们提交代码，后端和测试都可以自行选择环境打包查看调试项目。\n造不造轮子无所谓，主要在这个过程中体验到了用心做一个产品的成就感和学到了很多知识，有时候上床睡觉了，但是灵感来了会忍不住起床敲代码验证并记录。😂</p>\n<p><img src=\"https://cdn.learnku.com/uploads/images/202004/01/6015/u6LDyoVEoi.png!large\" alt=\"Snackbar\"></p>\n<p>## 设计思路</p>\n<p>我设计了三张表，分别是</p>\n<p>仓库</p>\n<pre class=\"prettyprint language-go\"><code>\ntype Repository struct {\n\n    gorm.Model\n\n    Name         string &#96;binding:&quot;required,min=2,max=20&quot;&#96;\n\n    Desc         string &#96;gorm:&quot;type:varchar(1000)&quot;&#96;\n\n    Url          string &#96;binding:&quot;url&quot;&#96;      &#x2F;&#x2F;仓库的地址\n\n    UserName     string                      &#x2F;&#x2F;仓库是私有的话需要填写\n\n    Password     string                      &#x2F;&#x2F;仓库是私有的话需要填写\n\n    Status       int                         &#x2F;&#x2F;此仓库是否已经将代码克隆过来\n\n    JobStatus    int                         &#x2F;&#x2F;有任务正在打包，其他任务无法执行\n\n    DependTools  string &#96;binding:&quot;required&quot;&#96; &#x2F;&#x2F;依赖工具选择\n\n    TerminalInfo string &#96;gorm:&quot;type:varchar(1000)&quot;&#96;\n\n}\n\n</code></pre><p>分类</p>\n<pre class=\"prettyprint language-go\"><code>\ntype Category struct {\n\n    gorm.Model\n\n    Name        string &#96;binding:&quot;required,min=2,max=20&quot;&#96;\n\n    JobQuantity int    &#96;gorm:&quot;default:0&quot;&#96;\n\n    Desc        string &#96;gorm:&quot;type:varchar(1000)&quot;&#96;\n\n}\n\n</code></pre><p>任务</p>\n<pre class=\"prettyprint language-go\"><code>\ntype Job struct {\n\n    gorm.Model\n\n    Name          string &#96;binding:&quot;required,min=2,max=20&quot;&#96;\n\n    Desc          string &#96;gorm:&quot;type:varchar(1000)&quot;,binding:&quot;required,min=2,max=999&quot;&#96;\n\n    Status        int    &#96;gorm:&quot;default:0&quot;&#96;        &#x2F;&#x2F;任务状态\n\n    Branch        string &#96;gorm:&quot;default:&#x27;master&#x27;&quot;&#96; &#x2F;&#x2F;部署分支默认master，用户在部署之前随时可以修改\n\n    Url           string                           &#x2F;&#x2F;访问目录，只有状态成功才返回\n\n    RunQuantity   int &#96;gorm:&quot;default:0&quot;&#96;\n\n    CategoryId    int &#96;gorm:&quot;index&quot;,binding:&quot;required&quot;&#96;\n\n    WebHookUrl    string\n\n    RepositoryId  int    &#96;gorm:&quot;index&quot;,binding:&quot;required&quot;&#96;\n\n    BuildDir      string &#96;binding:&quot;required&quot;&#96; &#x2F;&#x2F;打包的目录,默认是dist\n\n    BuildCommand  string &#96;binding:&quot;required&quot;&#96; &#x2F;&#x2F;打包命令，npm run build 可以读取package.json供选择\n\n    Password      string                      &#x2F;&#x2F;任务加密\n\n    TerminalInfo  string &#96;gorm:&quot;type:varchar(1000)&quot;&#96;\n\n    SuccessScript string &#96;gorm:&quot;type:varchar(1000)&quot;&#96; &#x2F;&#x2F;打包成功运行的脚本，多个用 ; 隔开\n\n}\n\n</code></pre><p>一开始并不是这些字段，在做的过程中不停的改了很多次，也删除了很多东西。</p>\n<hr>\n<p>仓库管理其实就是将仓库克隆过来通过仓库ID来管理代码。每次任务运行的时候会去更新代码安装js依赖并切换分支然后打包，并将打包的代码通过任务ID管理并提供访问。一句话好像就总结完了，但是在写的过程中考虑了很多东西。如，同一个仓库需要打包多套环境，切换分支的时候如何锁定仓库、打包出错怎么反馈给用户、依赖在什么时候安装，安装失败了如何处理、不同的任务切换分支的时候如何处理新的代码、安装依赖的时候使用什么工具等</p>\n<p>反正就是边想边做，也画了很多草稿。</p>\n<hr>\n<p>其实最让我头疼的就是目录结构和包的职责，因为不小心就循环引用包了，特别是 helper 包，他提供一些常用的方法，刚开始我会在这个包里引用其他自己定义的包，其实不应该这样做，这些工具函数不应该依赖其他自定义的包，他应该是职责单一独立无依赖的，如果需要依赖自定义的包，那么应该考虑放到相应的服务里面。</p>\n<hr>\n<p>然后我是个前端，以前写过一点 Laravel ，所以后端的目录有点像之前的结构 ，并且重构了很多次。\n前端代码组织也做了很多次调整，UI界面的调整也很多，不停的去寻找最好的解决方式吧，同时也还有很多不足的地方，也欢迎大家提出问题一起交流，后续也会添加更多工具，陆续的将一些好创意添加进去。</p>\n<p>还有一个感触比较深的就是把简单的问题复杂化很简单，把复杂的问题简单化很难。</p>\n<p>## 角色权限</p>\n<p>开始的时候就只做了上面的核心功能，已经可以使用了，但是在公司推广开了之后，发现用户和权限模块也是非常重要的，于是就添加了用户模块和权限的简单设计。</p>\n<p>角色目前分为超级管理员、管理员、开发者、项目记者。权限如下：</p>\n<p>- 项目记者 - 只能查看所有内容，并且可以访问打包好的</p>\n<p>- 开发者 - 拥有创建仓库、分类、任务和拉代码、切换分支、运行打包、删除依赖权限</p>\n<p>- 管理员 - 可以删除仓库、分类、任务</p>\n<p>- 超级管理员 -可以管理用户（提升和降级角色，删除用户）</p>\n<p>注：等级高的角色拥有低级角色的全部权限。用户注册默认成为项目记者，如果注册的名字是 Admin 会自动成为超级管理员，注册名字不可重复。</p>\n</div>",
            "title": "👏👏👏MareWood 开源了。MareWood 是一个类似于 Jenkins 漂亮的轻量级前端部署工具",
            "last_reply_at": "2020-04-02T11:09:52.635Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 1243,
            "create_at": "2020-04-01T10:11:34.738Z",
            "author": {
                "loginname": "xusenlin",
                "avatar_url": "https://avatars1.githubusercontent.com/u/14531906?v=4&s=120"
            }
        },
        {
            "id": "5e85821458ab6717beb7dd31",
            "author_id": "5cf726571fe902120f31c3a5",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>简历上写了自己些自己的项目，以及对应的技术，还有自己怎么研究之类，为啥面试官说没有亮点？</p>\n</div>",
            "title": "请问前端工程师简历上啥叫亮点？",
            "last_reply_at": "2020-04-02T06:57:09.172Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 999,
            "create_at": "2020-04-02T06:11:32.456Z",
            "author": {
                "loginname": "SquabbyZ",
                "avatar_url": "https://avatars0.githubusercontent.com/u/43177939?v=4&s=120"
            }
        }
    ]
}